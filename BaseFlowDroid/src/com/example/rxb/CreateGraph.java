package com.example.rxb;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import soot.SootMethod;
import soot.Unit;
import soot.jimple.infoflow.solver.IInfoflowCFG;

public class CreateGraph {
	 static NewDirectedGraph dir;
	 static List<UnitEdge> edgeList = new ArrayList<>();
	 static List<UnitVertex> labelVertex=new ArrayList<UnitVertex>();
	 static UnitEdge[] edgeArray;
	 static UnitVertex[] vertexArray;
	 public static IInfoflowCFG iCfg;
	 static String regEx="^.*[a-zA-Z]*[\\(]{1}.*[\\)]$";
	 static Set<String> APIs = new HashSet<String>();
	 static Collection<Unit> needDelete=new ArrayList<Unit>();
	 static List<String> sourcesAndSinks = new ArrayList<String>();
	 static CaculateSourceAndSink css=new CaculateSourceAndSink();
	 static List<Unit> deleteUnit=new ArrayList<Unit>();
	 static List<Unit> alreadyAdd=new ArrayList<Unit>();
	 public static UnitGraph getGraph(){
	
	CompGraph.compAndDeleteExtraEdge();
	iCfg = getDirectedGraph.iCfg;
	APIs=API.readAPI("E:\\period\\我的研一\\伊阳贵毕业设计\\soot-infoflow-android-develop\\API.txt");
	try {
		sourcesAndSinks=css.calculateSourcesSinksEntrypoints("E:\\period\\我的研一\\伊阳贵毕业设计\\soot-infoflow-android-develop\\SourcesAndSinks.txt");
	} catch (IOException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
	dir=CompGraph.newDG;
	
	for(Unit unit:dir.unitChain){

		if(unit.getClass().toString().equals("class soot.jimple.internal.JInvokeStmt")||(unit.getClass().toString().equals("class soot.jimple.internal.JAssignStmt")&&unit.toString().matches(regEx))){
		Collection<SootMethod> colls = iCfg.getCalleesOfCallAt(unit);
		List<String> collStr=new ArrayList<String>();
		for(SootMethod m:colls){
			collStr.add(m.toString().substring(m.toString().indexOf("<")+1,m.toString().lastIndexOf(">")));
		}
		if(collStr.isEmpty()){
			collStr.add(unit.toString().substring(unit.toString().indexOf("<")+1,unit.toString().lastIndexOf(">")));
		}
		boolean judge = false;
			for (String c : collStr) {				
				if (APIs.contains(c)||sourcesAndSinks.contains(c)) {
					judge = true;
					break;
				}
			}
if(!judge){

	List<Unit> preds=new ArrayList<Unit>(dir.getPredsOf(unit));
	List<Unit> succs=new ArrayList<Unit>(dir.getSuccsOf(unit));
	for(Unit pred:preds){	
	  		dir.getSuccsOf(pred).remove(unit);
	  		for(Unit succ:succs){
	  		if(!dir.getSuccsOf(pred).contains(succ)){
	  			dir.getSuccsOf(pred).add(succ);		
	  		}
	  	}
	}
		for(Unit succ:succs){	
//			if(!succ.toString().equals(unit.toString())){
			dir.getPredsOf(succ).remove(unit);	
//			System.out.println("后继�?+succ);
	  	
	  for(Unit pred:preds){
		if(!dir.getPredsOf(succ).contains(pred)){
			dir.getPredsOf(succ).add(pred);
		  }
	  }
//		System.out.println("剩前�?+dir.getPredsOf(succ));
//   }
		}
		dir.getPredsOf(unit).clear();
		dir.getSuccsOf(unit).clear();
		needDelete.add(unit);
}
		
	}
	}

	for(Unit unit:dir.unitChain){
		removeDuplicate(dir.getSuccsOf(unit));
	}
//	dir.unitChain.removeAll(needDelete);
	for(Unit unit:dir.unitChain){
		for(Iterator<Unit> it=dir.getSuccsOf(unit).iterator();it.hasNext();){
			Unit unitIt=it.next();
			if(!dir.unitChain.contains(unitIt)){
				it.remove();
			}
		}
	}
//    for(Unit unit:dir.unitChain){
//	
//	if(unit.getClass().toString().equals("class com.example.rxb.dummyLoop")){
//	
//		if(unit.toString().contains("enterOf")){
//			if(dir.getSuccsOf(unit).size()==1){
//				Unit u1=dir.getSuccsOf(unit).get(0);
//				if(u1.toString().contains("returnOf")){
//					if(dir.getPredsOf(u1).size()==1)
//					{
//						Unit temp=dir.getPredsOf(u1).get(0);
//						if(temp.equals(unit)){
//					    for (Unit pred : dir.getPredsOf(unit)) {
//						dir.getSuccsOf(pred).remove(unit);
//						for (Unit succ : dir.getSuccsOf(unit)) {
//							if (!dir.getSuccsOf(pred).contains(succ)) {
////								dir.getSuccsOf(pred).remove(unit);
//								dir.getSuccsOf(pred).add(succ);
////								pred.addSuccs(succ);
//							  }
//						    }
//        		         }
//					     for(Unit succ:dir.getSuccsOf(u1)){
//						 dir.getPredsOf(succ).remove(unit);
//						 for (Unit pred : dir.getPredsOf(unit)) {
//							if (!dir.getPredsOf(succ).contains(pred)) {
////								dir.getSuccsOf(pred).remove(unit);
//								dir.getPredsOf(succ).add(pred);
////								pred.addSuccs(succ);
//							   }
//						    }	
//					      }
//					    needDelete.add(unit);
//					    needDelete.add(u1);
//						}
//					}
////					for(Unit pred:dir.getPredsOf(unit)){
////						dir.getSuccsOf(pred).remove(unit);
////						for(Unit pred2:dir.)
////					}
////					for(Unit succ:dir.getSuccsOf(u1)){
////						
////					}
//				}
////			for(Unit u1:dir.getSuccsOf(unit)){
//				
////				if(u1.toString().contains("exitOf")){
////				
////				}	
////			}	
//			}
//			}
//		}
////		if((dir.getPredsOf(unit).isEmpty()||dir.getPredsOf(unit).size()==1)&&(dir.getSuccsOf(unit).isEmpty()||dir.getSuccsOf(unit).size()==1))
////	}
//    }
    dir.unitChain.removeAll(needDelete);
	
	for(Unit unit:dir.unitChain){
		
//		System.out.println("Unit节点�?+unit);
		for(Unit succ:dir.getSuccsOf(unit)){
//			System.out.println("节点的后继："+succ);
			if(dir.unitChain.contains(succ)){
//				if(!edgeList.contains(new Edge(unit,succ)))
//				{
			edgeList.add(new UnitEdge(unit,succ));
//				}
			
			}
			if(!dir.unitChain.contains(succ)){
			deleteUnit.add(succ);
			}
		}
//		if(!labelVertex.contains(new Vertex(unit)))
//		{
		labelVertex.add(new UnitVertex(unit));
//		}
	}
//	removeDuplicateV(labelVertex);
	edgeArray=new UnitEdge[edgeList.size()];
	vertexArray=new UnitVertex[labelVertex.size()];
System.out.println("边数"+edgeList.size());
for(UnitEdge s:edgeList){
	System.out.println("存在的边"+s.beginlabel+" "+s.beginlabel);
}
int i=1;
for(UnitVertex s:labelVertex){
	System.out.println(i+"剩余节点"+s.getLabel());
	i++;
}
	return new UnitGraph(labelVertex.toArray(vertexArray),edgeList.toArray(edgeArray));
}
public static List<Unit> removeDuplicate(List<Unit> list)  {       
  for  ( int  i  =   0 ; i  <  list.size()  -   1 ; i ++ )  {       
		      for  ( int  j  =  list.size()  -   1 ; j  >  i; j -- )  {       
		           if  (list.get(j).equals(list.get(i)))  {       
		              list.remove(j);       
		            }        
		        }        
		      }        
		    return list;       
		}

public static void main(final String[] args) {
	getGraph();
}
}
