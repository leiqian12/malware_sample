package com.example.rxb;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Stack;

import soot.Unit;

public class DummyMainFilter {
	 static ArrayList<Queue<Unit>> paths=new ArrayList<Queue<Unit>>();
	 static String regEx = "^.*[a-zA-Z]*[\\(]{1}.*[\\)]$";
	 public static ArrayList<Queue<Unit>> dfs(List<Unit> starts,HashMap<Unit,List<Unit>> selfToSuccess,List<Unit> tails) {
	    	Queue<Unit> path = new LinkedList<>();
	        HashSet<Unit> visited = new HashSet<>();// 用来判断某个顶点是否已经访问了
	        LinkedList<Unit> stack = new LinkedList<>();// 模拟递归遍历中的栈
        for(Unit start:starts){
	        stack.push(start);
	        path.add(start);
	        visited.add(start);

	        while (!stack.isEmpty()) {
	            Unit next = null;// 下一个待遍历的顶点
	            Unit currentVertex = stack.peek();// 当前正在遍历的顶点
	            List<Unit> neighbors=selfToSuccess.get(currentVertex);// 获取当前顶点的邻接表
	            if (neighbors != null) {
	                for (Unit vertex : neighbors) {
	                    if (!visited.contains(vertex))// vertex 未被访问过
	                    {
	                        next = vertex;
	                        break;
	                    }
	                }
	            }// end if

	            if (next != null)// 当前顶点还有未被访问的邻接点
	            {
	              if((next.getClass().toString().equals("class soot.jimple.internal.JInvokeStmt")&&!next.toString().contains(": void <init>("))||(next.getClass().toString().equals("class soot.jimple.internal.JAssignStmt")
					&& next.toString().matches(regEx))||tails.contains(next))
	            	{
	                path.add(next);// 将该邻接点添加到访问路径中
	            	}
	                stack.push(next);
	                visited.add(next);
	            } else {
	                stack.pop();// 回退
	            }
	        }// end while
        }
	        paths.add(path);
	        return paths;
	    }

	   
}
