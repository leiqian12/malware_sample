package com.example.rxb;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Map.Entry;

import soot.Body;
import soot.G;
import soot.PatchingChain;
import soot.SootMethod;
import soot.Unit;
import soot.UnitBox;
import soot.options.Options;
import soot.toolkits.graph.DirectedGraph;
import soot.toolkits.graph.UnitGraph;
import soot.util.Chain;
import soot.util.HashChain;

public class NewDirectedGraph implements DirectedGraph<Unit>{
	  protected List<Unit> heads;
	    protected List<Unit> tails;
	    protected Map<Unit,ArrayList<Unit>> unitToSuccs;
	    protected Map<Unit,ArrayList<Unit>> unitToPreds;        
	    protected SootMethod method;
	    protected Body body;
	    protected PatchingChain<Unit> unitChain=new PatchingChain<Unit>(new HashChain<Unit>());;

	    public Chain<Unit> getUnitChain() {
			return unitChain;
		}
		public void setUnitChain(PatchingChain<Unit> Chain) {
			this.unitChain = Chain;
		}
		protected NewDirectedGraph( Body body) {
	    	this.body = body;
	    	unitChain = body.getUnits();
	            method = body.getMethod();
	            if(Options.v().verbose())
	    	    G.v().out.println("[" + method.getName() + "]     Constructing " + 
	    			      this.getClass().getName() + "...");
	          
	        }
	    protected NewDirectedGraph(List<Unit> h,List<Unit> t,Map<Unit, ArrayList<Unit>> uTS,Map<Unit, ArrayList<Unit>> uTP,SootMethod sm,PatchingChain<Unit> uc) {
	    	this.heads = h;
	    	this.tails=t;
	    	this.unitToSuccs=uTS;
	    	this.unitToPreds=uTP;
	    	this.method=sm;
	    	this.unitChain=uc;
//	    	unitChain = body.getUnits();
//	            method = body.getMethod();
//	            if(Options.v().verbose())
//	    	    G.v().out.println("[" + method.getName() + "]     Constructing " + 
//	    			      this.getClass().getName() + "...");
//	          
	        }
//		 public static SootMethod dummy;
//		 protected List<Unit> dummyHeads;
//		 protected List<Unit> dummyTails;
//		 protected Map<SootMethod, List<Unit>> heads;
//		 protected Map<SootMethod, List<Unit>> tails;
//		 public Map<Unit,List<Unit>> unitToSuccs;
//		 public Map<Unit,List<Unit>> unitToPreds;        
//		 protected List<Unit> unitChain;
//	 NewDirectedGraph(SootMethod sm,List<Unit> dummyheads,List<Unit> dummytails,Map<SootMethod,List<Unit>> head,Map<SootMethod,List<Unit>> tail,Map<Unit,List<Unit>> unitTosuccs,Map<Unit,List<Unit>> unitTopreds,List<Unit> unitchain){
//    	 this.dummy=sm;
//		 this.dummyHeads=dummyheads;
//    	 this.dummyTails=dummytails;
//    	 this.heads=head;
//    	 this.tails=tail;
//    	 this.unitToSuccs=unitTosuccs;
//    	 this.unitToPreds=unitTopreds;
//    	 this.unitChain=unitchain;
//     }
//	 public List<Unit> getDummyHeads(){
//			return this.dummyHeads;
//		}
//		public List<Unit> getDummyTails(){
//			return this.dummyTails;
//		}
//	public List<Unit> getHeads(SootMethod sm) {
//		// TODO Auto-generated method stub
//		 if(!heads.containsKey(sm)) 
//			    throw new NoSuchElementException("Invalid unit " + sm);
//
//		        return heads.get(sm);
//	}
//
//	public List<Unit> getTails(SootMethod sm) {
//		// TODO Auto-generated method stub
//		 if(!tails.containsKey(sm)) 
//			    throw new NoSuchElementException("Invalid unit " + sm);
//
//		        return tails.get(sm);
//	}
//
//	 public List<Unit> getPredsOf(Unit u)
//	    {
//	        if(!unitToPreds.containsKey(u)) 
//		    throw new NoSuchElementException("Invalid unit " + u);
//
//	        return unitToPreds.get(u);
//	    }
//
//	    public List<Unit> getSuccsOf(Unit u)
//	    {
////			List<Unit> l = unitToSuccs.get(u);
////	        if (l == null) throw new RuntimeException("Invalid unit " + u);
////	        return l;
//	    	   if(!unitToSuccs.containsKey(u)) 
//	   		    throw new NoSuchElementException("Invalid unit " + u);
//
//	   	        return unitToSuccs.get(u);
//	    }
//
//
//	    public int size()
//	    {
//	        return unitChain.size();
//	    }  
//
//	    public Iterator<Unit> iterator()
//	    {
//	        return unitChain.iterator();
//	    }
//		public Map<SootMethod, List<Unit>> getAllHeads() {
//			// TODO Auto-generated method stub
//			return this.heads;
//		}
//		public Map<SootMethod, List<Unit>> getAllTails() {
//			// TODO Auto-generated method stub
//			return this.tails;
//		}
//		@Override
//		public List getHeads() {
//			// TODO Auto-generated method stub
//			return null;
//		}
//		@Override
//		public List getTails() {
//			// TODO Auto-generated method stub
//			return null;
//		}
//		@Override
//		public List getPredsOf(Object s) {
//			// TODO Auto-generated method stub
//			return null;
//		}
//		@Override
//		public List getSuccsOf(Object s) {
//			// TODO Auto-generated method stub
//			return null;
//		}
//	
//
//
//
//}
	    protected void buildUnexceptionalEdges(Map<Unit,List<Unit>> unitToSuccs, Map<Unit,List<Unit>> unitToPreds) {

	    	// Initialize the predecessor sets to empty
	    	for (Unit u : unitChain) {
	    	    unitToPreds.put(u, new ArrayList<Unit>());
	    	}
	    	
	    	Iterator<Unit> unitIt = unitChain.iterator();
	    	Unit currentUnit, nextUnit;
	                    
	    	nextUnit = unitIt.hasNext() ? (Unit) unitIt.next(): null;
	                    
	    	while(nextUnit != null) {
	    	    currentUnit = nextUnit;
	    	    nextUnit = unitIt.hasNext() ? (Unit) unitIt.next(): null;
	                        
	    	    List<Unit> successors = new ArrayList<Unit>();
	                        
	    	    if( currentUnit.fallsThrough() ) {
	    		// Add the next unit as the successor
	    		if(nextUnit != null) {
	    		    successors.add(nextUnit);
	    		    unitToPreds.get(nextUnit).add(currentUnit);
	    		}
	    	    }
	                            
	    	    if( currentUnit.branches() ) {
	    		for (UnitBox targetBox : currentUnit.getUnitBoxes()) {
	    		    Unit target = targetBox.getUnit();
	    		    // Arbitrary bytecode can branch to the same
	    		    // target it falls through to, so we screen for duplicates:
	    		    if (! successors.contains(target)) {
	    			successors.add(target);
	    			List<Unit> preds = unitToPreds.get(target);
	    			if (preds == null)
	    				throw new RuntimeException("Unit graph contains jump to non-existing target");
	    			preds.add(currentUnit);
	    		    }
	    		}
	    	    }

	    	    // Store away successors
	    	    unitToSuccs.put(currentUnit, successors);
	    	}
	        }


	        /**
	         * <p>Utility method used in the construction of {@link UnitGraph}s, to be
	         * called only after the unitToPreds and unitToSuccs maps have
	         * been built.</p>
	         *
	         * <p><code>UnitGraph</code> provides an implementation of
	         * <code>buildHeadsAndTails()</code> which defines the graph's set
	         * of heads to include the first {@link Unit} in the graph's body,
	         * together with any other <tt>Unit</tt> which has no predecessors.
	         * It defines the graph's set of tails to include all
	         * <tt>Unit</tt>s with no successors.  Subclasses of
	         * <code>UnitGraph</code> may override this method to change the
	         * criteria for classifying a node as a head or tail.</p>
	         */
	        protected void buildHeadsAndTails() {
	    	List<Unit> tailList = new ArrayList<Unit>();
	    	List<Unit> headList = new ArrayList<Unit>();

	    	for (Unit s : unitChain ) {
	    	    List<Unit> succs = unitToSuccs.get(s);
	    	    if(succs.isEmpty()) {
	    		tailList.add(s);
	    	    }
	    	    List<Unit> preds = unitToPreds.get(s);
	    	    if(preds.isEmpty()) {
	    		headList.add(s);
	    	    }
	    	}

	    	// Add the first Unit, even if it is the target of
	    	// a branch.
	    	if (!unitChain.isEmpty()) {
	    		Unit entryPoint = (Unit) unitChain.getFirst();
	    		if (! headList.contains(entryPoint)) {
	    		    headList.add(entryPoint);
	    		}
	    	}

	    	tails = Collections.unmodifiableList(tailList);
	    	heads = Collections.unmodifiableList(headList);
	        }


	        /**
	         * Utility method that replaces the values of a {@link Map}, 
	         * which must be instances of {@link List}, with unmodifiable
	         * equivalents.
	         * 
	         * @param map      The map whose values are to be made unmodifiable.
	         */
	        protected static void makeMappedListsUnmodifiable(Map<?,List<Unit>> map) {
	    	for (Entry<?, List<Unit>> entry : map.entrySet()) {
	    	    List<Unit> value = entry.getValue();
	    	    if (value.size() == 0) {
	    		entry.setValue(Collections.<Unit>emptyList());
	    	    } else {
	    		entry.setValue(Collections.unmodifiableList(value));
	    	    }
	    	}
	        }


	        /**
	         * Utility method that produces a new map from the {@link Unit}s
	         * of this graph's body to the union of the values stored in the
	         * two argument {@link Map}s, used to combine the maps of
	         * exceptional and unexceptional predecessors and successors into
	         * maps of all predecessors and successors. The values stored in
	         * both argument maps must be {@link List}s of {@link Unit}s,
	         * which are assumed not to contain any duplicate <tt>Unit</tt>s.
	         * 
	         * @param mapA      The first map to be combined. 
	         *
	         * @param mapB	The second map to be combined.
	         */
	        protected Map<Unit,List<Unit>> combineMapValues
	        	(Map<Unit,List<Unit>> mapA, Map<Unit,List<Unit>> mapB) {
	    	// The duplicate screen 
	    	Map<Unit,List<Unit>> result = new HashMap<Unit,List<Unit>>(mapA.size() * 2 + 1, 0.7f);
	    	for (Unit unit : unitChain) {
	    	    List<Unit> listA = mapA.get(unit);
	    	    if (listA == null) {
	    		listA = Collections.emptyList();
	    	    }
	    	    List<Unit> listB = mapB.get(unit);
	    	    if (listB == null) {
	    		listB = Collections.emptyList();
	    	    }

	    	    int resultSize = listA.size() + listB.size();
	    	    if (resultSize == 0) {
	    		result.put(unit, Collections.<Unit>emptyList());
	    	    } else {
	    		List<Unit> resultList = new ArrayList<Unit>(resultSize);
	    		List<Unit> list = null;
	    		// As a minor optimization of the duplicate screening, 
	    		// copy the longer list first.
	    		if (listA.size() >= listB.size()) {
	    		    resultList.addAll(listA);
	    		    list = listB;
	    		} else {
	    		    resultList.addAll(listB);
	    		    list = listA;
	    		}
	    		for (Unit element : list) {
	    		    // It is possible for there to be both an exceptional
	    		    // and an unexceptional edge connecting two Units
	    		    // (though probably not in a class generated by
	    		    // javac), so we need to screen for duplicates. On the
	    		    // other hand, we expect most of these lists to have
	    		    // only one or two elements, so it doesn't seem worth
	    		    // the cost to build a Set to do the screening.
	    		    if (! resultList.contains(element)) {
	    			resultList.add(element);
	    		    }
	    		}
	    		result.put(unit, Collections.unmodifiableList(resultList));
	    	    }
	    	}
	    	return result;
	        }


	        /**
	         * Utility method for adding an edge to maps representing the CFG.
	         * 
	         * @param unitToSuccs The {@link Map} from {@link Unit}s to {@link List}s
	         *                    of their successors.
	         *
	         * @param unitToPreds The {@link Map} from {@link Unit}s to {@link List}s
	         *                    of their successors.
	         *
	         * @param head     The {@link Unit} from which the edge starts.
	         *
	         * @param tail     The {@link Unit} to which the edge flows.
	         */
	        protected void addEdge(Map<Unit,List<Unit>> unitToSuccs, Map<Unit,List<Unit>> unitToPreds,
	    			   Unit head, Unit tail) {
	    	List<Unit> headsSuccs = unitToSuccs.get(head);
	    	if (headsSuccs == null) {
	    	    headsSuccs = new ArrayList<Unit>(3); // We expect this list to
	    					   // remain short.
	    	    unitToSuccs.put(head, headsSuccs);
	    	}
	    	if (! headsSuccs.contains(tail)) {
	    	    headsSuccs.add(tail);
	    	    List<Unit> tailsPreds = unitToPreds.get(tail);
	    	    if (tailsPreds == null) {
	    		tailsPreds = new ArrayList<Unit>();
	    		unitToPreds.put(tail, tailsPreds);
	    	    }
	    	    tailsPreds.add(head);
	    	}
	        }


	        /**
	         *   @return The body from which this UnitGraph was built.
	         *
	         *  @see Body
	         */
	        public Body getBody()
	        {
	            return body;
	        }



	      /**
	       *  Look for a path in graph,  from def to use. 
	       *  This path has to lie inside an extended basic block 
	       *  (and this property implies uniqueness.). The path returned 
	       *   includes from and to.
	       *
	       *  @param from start point for the path.
	       *  @param to   end point for the path. 
	       *  @return null if there is no such path.
	       */
	      public List<Unit> getExtendedBasicBlockPathBetween(Unit from, Unit to)
	        {
	            NewDirectedGraph g = this;
	            
	          // if this holds, we're doomed to failure!!!
	          if (g.getPredsOf(to).size() > 1)
	            return null;

	          // pathStack := list of succs lists
	          // pathStackIndex := last visited index in pathStack
	          LinkedList<Unit> pathStack = new LinkedList<Unit>();
	          LinkedList<Integer> pathStackIndex = new LinkedList<Integer>();

	          pathStack.add(from);
	          pathStackIndex.add(new Integer(0));

	          int psiMax = (g.getSuccsOf(pathStack.get(0))).size();
	          int level = 0;
	          while (pathStackIndex.get(0).intValue() != psiMax)
	            {
	              int p = (pathStackIndex.get(level)).intValue();

	              List<Unit> succs = g.getSuccsOf((pathStack.get(level)));
	              if (p >= succs.size())
	                {
	                  // no more succs - backtrack to previous level.

	                  pathStack.remove(level);
	                  pathStackIndex.remove(level);

	                  level--;
	                  int q = pathStackIndex.get(level).intValue();
	                  pathStackIndex.set(level, new Integer(q+1));
	                  continue;
	                }

	              Unit betweenUnit = (Unit)(succs.get(p));

	              // we win!
	              if (betweenUnit == to)
	                {
	                  pathStack.add(to);
	                  return pathStack;
	                }

	              // check preds of betweenUnit to see if we should visit its kids.
	              if (g.getPredsOf(betweenUnit).size() > 1)
	                {
	                  pathStackIndex.set(level, new Integer(p+1));
	                  continue;
	                }

	              // visit kids of betweenUnit.
	              level++;
	              pathStackIndex.add(new Integer(0));
	              pathStack.add(betweenUnit);
	            }
	          return null;
	        }       


	        /* DirectedGraph implementation */
	        public List<Unit> getHeads()
	        {
	            return heads;
	        }

	        public List<Unit> getTails()
	        {
	            return tails;
	        }

	        public List<Unit> getPredsOf(Unit u)
	        {
	            if(!unitToPreds.containsKey(u)) 
	    	    throw new NoSuchElementException("Invalid unit " + u);

	            return unitToPreds.get(u);
	        }

	        public List<Unit> getSuccsOf(Unit u)
	        {
	    		List<Unit> l = unitToSuccs.get(u);
	            if (l == null) throw new RuntimeException("Invalid unit " + u);
	            return l;
	        }

	        public int size()
	        {
	            return unitChain.size();
	        }  

	        public Iterator<Unit> iterator()
	        {
	            return unitChain.iterator();
	        }

	        public String toString() 
	        {
	            StringBuffer buf = new StringBuffer();
	            for (Unit u : unitChain) {
	                buf.append("// preds: "+getPredsOf(u)+"\n");
	                buf.append(u.toString() + '\n');
	                buf.append("// succs "+getSuccsOf(u)+"\n");
	            }
	            return buf.toString();
	        }
		
	    }
