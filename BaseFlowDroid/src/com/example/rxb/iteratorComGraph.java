package com.example.rxb;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import org.xmlpull.v1.XmlPullParserException;
import com.example.af.AFVertex;
import soot.SootClass;
import soot.SootMethod;
import soot.Unit;
import soot.jimple.Stmt;
import soot.jimple.infoflow.Infoflow;
import soot.jimple.infoflow.android.axml.AXmlNode;
import soot.jimple.infoflow.android.manifest.ProcessManifest;
import soot.jimple.infoflow.solver.IInfoflowCFG;
import soot.util.Chain;

public class iteratorComGraph {
	static List<Unit> visitedVertex=new ArrayList<Unit>();
	public static IInfoflowCFG iCfg;
	public static Infoflow info = new Infoflow();
	public static List<NewDirectedGraph> newDGList = new ArrayList<NewDirectedGraph>();
	public static LinkedList<Unit> paths;
	public static Map<SootMethod, LinkedList<Unit>> methodOfPath = new HashMap<SootMethod, LinkedList<Unit>>();
	public static Map<SootMethod, LinkedList<Unit>> tempMethodOfPath = new HashMap<SootMethod,LinkedList<Unit>>();
	public static Set<Unit> visited;
	public static Collection<SootMethod> allMethod;
	public static List<List<Unit>> insertedPathList = new ArrayList<List<Unit>>();
    public static Map<Unit,Loop> unitMappingLoop=new HashMap<Unit,Loop>();
    static Set<Integer> searched = new HashSet<>();
    public static int dummyMainIndex;
    public static List<SootMethod> recursion=new ArrayList<SootMethod>();
	public static Vertex[] vertexArrayCFG;
	static List<AFVertex> labelVertex=new ArrayList<AFVertex>();
	static String regEx = "^.*[a-zA-Z]*[\\(]{1}.*[\\)]$";
	public static List<SootMethod> methodsWithPath=new ArrayList<SootMethod>();
	public static Map<SootMethod,LinkedList<Unit>> replaceMethodOfPath=new HashMap<SootMethod,LinkedList<Unit>>();
	public static Map<Boolean, List<Unit>> overed = new HashMap<Boolean, List<Unit>>();
	//只是用来暂时存放一条路径衍生出来的产生多条路径，和insertedPathList相互切换
	public static List<List<Unit>> step2InsertedPathList = new ArrayList<List<Unit>>();
	//得到的用于下一轮迭代的路径集合，由每一个路径节点遍历完成后step2InsertedPathList和insertedPathList更新（逐渐加入）
	public static List<List<Unit>> newIteratorList = new ArrayList<List<Unit>>();
	//存放迭代完成的最终路径，这些路径将不参与下一次迭代
	public static List<List<Unit>> overInsertedPathList = new ArrayList<List<Unit>>();
	//存放用于下一轮迭代的路径集合，在上一轮完成后由newIteratorList更新，newIteratorList清空，用于记录下一次产生的新路径
	public static List<List<Unit>> replaceInsertedPathList = new ArrayList<List<Unit>>();
	public static Map<SootMethod,List<SootMethod>> methodList=new HashMap<SootMethod,List<SootMethod>>();
	static List<LinkedList<SootMethod>> allCycle = new ArrayList<LinkedList<SootMethod>>();
	public static List<LinkedList<Unit>> recursionPathList = new ArrayList<LinkedList<Unit>>();
	public static List<LinkedList<Unit>> sumRecursionPathList = new ArrayList<LinkedList<Unit>>();
	public static List<Queue<Unit>> noRecursionPathList = new ArrayList<Queue<Unit>>();
	public static LinkedList<Unit> delRecursion;
	public static Set<UnitEdge> edges=new HashSet<UnitEdge>();
	static UnitEdge[] edgeArray;
	 public static AFVertex[] vertexArrayAF;
	 static Set<String> sourcesAndSinks = new HashSet<String>();
	 static CaculateSourceAndSink css=new CaculateSourceAndSink();
	 static Set<String> APIs = new HashSet<String>();
	 static int LoopNumber=0;
	 public static String regEx2="label[0-9]*[:]{1}.*$";
	 static List<String> sourceAndSinks=new LinkedList<String>();
	 public static void main(final String[] args) {
		//在CFG中找环并将换压缩，找路径
		 CaculateSourceAndSink css=new CaculateSourceAndSink();
		 try {
			sourceAndSinks=css.calculateSourcesSinksEntrypoints("H:\\SourcesAndSinks.txt");
		} catch (IOException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} 
		findLoop();
//		System.out.println("环的个数："+LoopNumber);
//		for(SootMethod sm:methodOfPath.keySet()){
//			System.out.println("方法："+sm);
//			System.out.println("路径："+methodOfPath.get(sm));
//			
//		}
		replaceLoop();
//		System.out.println("完成替代环");
		//对递归的处理
//		
//		System.out.println("替代环后：");
//		for(SootMethod sm:replaceMethodOfPath.keySet()){
//			System.out.println("后方法："+sm);
//			System.out.println("后路径："+replaceMethodOfPath.get(sm));
//			
//		}
		iteratorCall();
//		for(SootMethod sm:tempMethodOfPath.keySet()){
//			methodOfPath.remove(sm);
//			methodOfPath.put(sm, tempMethodOfPath.get(sm));
//		}
		
//		try {
//			getPermissionMapping();
//			getcallBackMapping();
//			compStartAPI();
//			classLoaderAPI();
//			sensitiveAPI();
//			systemCallback();
//			Cipher();
//			Permission();
//			
//		} catch (Exception e) {
//			// TODO Auto-generated catch block
//			e.printStackTrace();
//		}
//		
		callbackPath();	
//		getFeature();
//		MenifestChecker();
//		System.out.println(featuresLabel.size());
//		for(Unit entr:entryPaths.keySet()){
//			System.out.println("方法："+entr+"路径 ："+entryPaths.get(entr));
//		}
//		String result="";
//		for(int i=0;i<features.length;i++)
//		{
//			result+=features[i]+",";
//		}
//		File file = new File("H:\\Result.txt");
//		    FileWriter fw;
//			try {
//				fw = new FileWriter(file.getAbsoluteFile());
//				BufferedWriter bw = new BufferedWriter(fw);
//				bw.write(result+"\r\n");
//				bw.flush();
//				bw.close();
//			} catch (IOException e) {
//				// TODO Auto-generated catch block
//				e.printStackTrace();
//			}
			
		   }
//	}
	 
	static List<String> callbacks=new LinkedList<String>();
	public static void getcallBackMapping() throws Exception {
	        // 需要处理数据的文件位置
	        FileReader fileReader = new FileReader(new File("H:\\Callback.txt"));
	        BufferedReader bufferedReader = new BufferedReader(fileReader);
	       	String readLine = null;
	      while ((readLine = bufferedReader.readLine()) != null) {
	        	callbacks.add(readLine.trim());
	        }
	    }
	static List<String> sensitiveAPI=new LinkedList<String>();
	public static void sensitiveAPI() throws Exception{
		 FileReader fileReader = new FileReader(new File("H:\\sensitive_API.txt"));
	        BufferedReader bufferedReader = new BufferedReader(fileReader);
	       	String readLine = null;
	      while ((readLine = bufferedReader.readLine()) != null) {
	    	  System.out.println("加入："+readLine.trim());
	    	  sensitiveAPI.add(readLine.trim());
	        } 
	 }
	static List<String> compStart=new LinkedList<String>();
	public static void compStartAPI() throws Exception{
		 FileReader fileReader = new FileReader(new File("H:\\Comp_start.txt"));
	        BufferedReader bufferedReader = new BufferedReader(fileReader);
	       	String readLine = null;
	      while ((readLine = bufferedReader.readLine()) != null) {
	    	    compStart.add(readLine.trim());
	        } 
	 }
	static List<String> classLoader=new LinkedList<String>();
	public static void classLoaderAPI() throws Exception{
		 FileReader fileReader = new FileReader(new File("H:\\Class_Loader.txt"));
	        BufferedReader bufferedReader = new BufferedReader(fileReader);
	       	String readLine = null;
	      while ((readLine = bufferedReader.readLine()) != null) {
	    	  if(!readLine.isEmpty())
	    	  {
	    	  classLoader.add(readLine.trim());
	    	  }
	        } 
	 }
	static List<String> permission=new LinkedList<String>();
	public static void Permission() throws Exception{
		 FileReader fileReader = new FileReader(new File("H:\\permission.txt"));
	        BufferedReader bufferedReader = new BufferedReader(fileReader);
	       	String readLine = null;
	      while ((readLine = bufferedReader.readLine()) != null) {
	    	
	    	  permission.add(readLine);
	        } 
	 }
	static List<String> permissionAPI=new LinkedList<String>();
	static Map<String, Map<String,List<String>>> allMap = new HashMap<String, Map<String,List<String>>>();	 
    public static void getPermissionMapping() throws Exception {
	        // 需要处理数据的文件位置
	        FileReader fileReader = new FileReader(new File("H:\\Permission_map.txt"));
	        BufferedReader bufferedReader = new BufferedReader(fileReader);
	       	Map<String,List<String>> methodMap=new HashMap<String,List<String>>();
	        String readLine = null;
	        List<String> permissions=new ArrayList<String>();
	        while ((readLine = bufferedReader.readLine()) != null) {
	           String[] strArray =readLine.replaceAll(" +"," ").split(" ");
	          
	           if(allMap.containsKey(strArray[0])){
//	        	   if(allMap.get(strArray[0]).containsKey(strArray[1])){
//	        		   allMap.get(strArray[0]).get(strArray[1]).add(strArray[2]);
//	        	   }
//	        	   else{
//	        		   permissions.clear();
//	        		   permissions.add(strArray[2]);
//	        		   allMap.get(strArray[0]).put(strArray[1], new ArrayList<String>(permissions));
//	        	   }

	        	   allMap.get(strArray[0]).put(strArray[1], Arrays.asList(strArray[2].split("->")));
	           }
	           else{
//	        	   permissions.clear();
//	    		   permissions.add(strArray[2]);
	    		   methodMap.put(strArray[1], Arrays.asList(strArray[2].split("->")));
	    		   allMap.put(strArray[0], new HashMap<String,List<String>>(methodMap));
	    		   methodMap.clear();
	           }	           
	           permissionAPI.add(strArray[0]+"->"+strArray[1]);
	        }
	    }
	public static void findLoop(){
		getDirectedGraph.getGraph();
		iCfg = getDirectedGraph.iCfg;
		newDGList = getDirectedGraph.newDGList;
		allMethod = info.getMethodsForSeeds(iCfg);
		for (NewDirectedGraph signalGraph : newDGList) {	
			//methodsWithPath：有路径的方法
			methodsWithPath.add(signalGraph.method);
			}
		for (NewDirectedGraph signalGraph : newDGList) {
			Collection<Loop> colls = LoopNestTree.computeLoops(signalGraph);
//			LoopNumber+=colls.size();
			if (!colls.isEmpty()) {
				LoopNestTree lnt = new LoopNestTree(colls);
				for (Loop loop : lnt) {
					if (lnt.addNestLoop() != null) {
						if (lnt.addNestLoop().contains(loop)) {
							continue;
						}					}
					Unit loopUnit = new dummyLoop("环节点" + loop.header);
					unitMappingLoop.put(loopUnit, loop);
					signalGraph.unitChain.add(loopUnit);
					signalGraph.unitToPreds.put(loopUnit, new ArrayList<Unit>());
					signalGraph.unitToSuccs.put(loopUnit, new ArrayList<Unit>());
					Collection<Stmt> exits = loop.getLoopExits();
					List<Unit> preds = signalGraph.getPredsOf(loop.header);
					for (Unit pred : preds) {
						if (!exits.contains((Stmt) pred) && !loop.loopStatements.contains((Stmt) pred)) {
							signalGraph.getSuccsOf(pred).remove(loop.header);
							if (!signalGraph.getSuccsOf(pred).contains(loopUnit)) {
								signalGraph.getSuccsOf(pred).add(loopUnit);
							}
							if (!signalGraph.getPredsOf(loopUnit).contains(pred)) {
								signalGraph.getPredsOf(loopUnit).add(pred);
							}
						}
					}
				
					for (Stmt exitStmt : exits) {
						List<Unit> succs = signalGraph.getSuccsOf(exitStmt);
						for (Unit succ : succs) {			
							if (!succ.equals((Unit) loop.header) && !loop.loopStatements.contains((Stmt) succ)) {						
								signalGraph.getPredsOf(succ).remove(exitStmt);
								if (!signalGraph.getPredsOf(succ).contains(loopUnit)) {
									signalGraph.getPredsOf(succ).add(loopUnit);
								}
								if (!signalGraph.getSuccsOf(loopUnit).contains(succ)) {
									signalGraph.getSuccsOf(loopUnit).add(succ);
								}
							}
						}
					}
				}
				for (Loop loop : colls) {
					for (Stmt loopNode : loop.loopStatements) {
						if (signalGraph.unitChain.contains((Unit) loopNode)) {
							signalGraph.unitChain.remove((Unit) loopNode);
						}
					}
				}
			}			
			for (Unit head : signalGraph.heads) {
				if(!head.toString().contains("@caughtexception"))
				{
				paths=DFSOrder.dfs(signalGraph, head);
//				String strFirst=null;
//				String strEnd=null;
//				int indexFirst=0;
//				int indexEnd=0;
//				boolean judge=false;
//				if(paths.toString().contains("BRANCH")){
//					judge=true;
//				}
//				LinkedList<Unit> replacePaths=new LinkedList<Unit>(paths);
//				while(judge)
//				{
//					boolean can=false;
//					paths=new LinkedList<Unit>(replacePaths);
//				for(Unit one:paths){
//					if(one.toString().contains("BRANCH_(")&&one.toString().contains("_OF")){
//						strFirst=one.toString().substring(one.toString().indexOf("BRANCH_(")+8, one.toString().indexOf("_OF"));
//						indexFirst=paths.indexOf(one);
//						can=true;
//					}
//					if(one.toString().contains(")_BRANCH")&&one.toString().contains("_OF")&&can){
//						strEnd=one.toString().substring(one.toString().indexOf(")_BRANCH")+8, one.toString().indexOf("_OF"));
//					    indexEnd=paths.indexOf(one);
//						break;
//					}
//					if(signalGraph.tails.contains(one)&&can)
//					{
//						strEnd=one.toString();
//						indexEnd=paths.indexOf(one);
//						break;
//					}
//				}
//				if(indexFirst!=0&&indexEnd!=0){
//					List<Unit> subList=paths.subList(indexFirst, indexEnd+1);					
//					replacePaths.removeAll(subList);
//					subList.set(0, new dummyLoop("("));
//					if(subList.get(subList.size()-1).toString().contains(")_BRANCH"))
//					{
//					subList.set(subList.size()-1,new dummyLoop(")"));
//					}
//					else
//					{
//					subList.add(new dummyLoop(")"));	
//					}
//					int index1=-1;
//					for(Unit pathNode:paths){
//						if(pathNode.toString().equals(strFirst)){
//							index1=paths.indexOf(pathNode);
//						     break;
//						}
//					}
//					if(index1!=-1){
//					 replacePaths.addAll(index1+1, subList);
//					}			
//				}
//				if(!replacePaths.toString().contains("BRANCH_(")){
//					judge=false;
//				}
//			  }
			methodOfPath.put(signalGraph.method,new LinkedList<Unit>(paths));
			}
			}
		}
	}
	public static Vertex findVertex(int index,Vertex[] labelArray){
		 return labelArray[index];
	 }
	public static void replaceLoop(){	

		for(SootMethod sm:methodOfPath.keySet()){
    		LinkedList<Unit> paths=methodOfPath.get(sm);
    			LinkedList<Unit> removedLoopPath = new LinkedList<Unit>();
    			boolean judge=false;
    		  for(Unit node:paths){
				if(unitMappingLoop.containsKey(node)){
					removedLoopPath.addAll(paths.indexOf(node),unitMappingLoop.get(node).loopStatements);
					judge=true;	
				}
				else{
					removedLoopPath.add(node);
				}
			}
    		  if(judge==true){
    			  replaceMethodOfPath.put(sm, new LinkedList<Unit>(removedLoopPath));
    		  }
    	}
//		for(SootMethod sm:replaceMethodOfPath.keySet()){
//			if(methodOfPath.containsKey(sm)){
//				methodOfPath.put(sm, replaceMethodOfPath.get(sm));
//			}
//		}
	}
    public static Map<SootMethod,Collection<SootMethod>> tryCatch=new HashMap<SootMethod,Collection<SootMethod>>();
  //找迭代调用
	public static void iteratorCall(){	
	    vertexArrayCFG = getDirectedGraph.vertexArray;
		CFGGraph graph = getDirectedGraph.graph;
		dummyMainIndex=getDirectedGraph.dummyMainIndex;
		int[][] e = graph.getAdjMat();
		int n = e.length;
		DsfCycle.deliver(e, n);
	
		DsfCycle.deleteDifferentSequenceSameCycle();
		for(List<Integer> list:DsfCycle.allCycle){
			List<SootMethod> oneCycle=new LinkedList<SootMethod>();
			for(int listIndex:list){
				oneCycle.add(findVertex(listIndex,vertexArrayCFG).getLabel().method());
			}
//			System.out.println("找到一个环");
			allCycle.add(new LinkedList<SootMethod>(oneCycle));
		}
	
		if(!allCycle.isEmpty())
		{
		for(LinkedList<SootMethod> oneCycle:allCycle){
			for(int i=0;i<oneCycle.size();i++){
			LinkedList<Unit> paths=methodOfPath.get(oneCycle.get(i));
			
			int j=i;
		while(true)
		{
			j=j+1;
			if(j==oneCycle.size()){
			j=0;
			}
			List<Unit> insertedPath = new LinkedList<Unit>();
//			System.out.println(x);	
			for(Unit pathNode:paths){
					
				Collection<SootMethod> methods=iCfg.getCalleesOfCallAt(pathNode);			
				if(methods.contains(oneCycle.get(j))){
						LinkedList<Unit> callPaths=methodOfPath.get(oneCycle.get(j));						
							insertedPath.addAll(callPaths);
						
					}
					else{
							insertedPath.add(pathNode);
					}
				}
				paths=new LinkedList<Unit>(insertedPath);
				if(j+1==i||(i==0&&j==oneCycle.size()-1)){
				    delRecursion=new LinkedList<Unit>();
					for(Unit point:	paths){
						if(iCfg.getCalleesOfCallAt(point).contains(oneCycle.get(i))){
							Unit newCall=new dummyLoop("signed_"+point.toString());
							delRecursion.add(newCall);
						}
						else{
							delRecursion.add(point);
						}
					}
					break;
				   }
		     	 }	
		       tempMethodOfPath.put(oneCycle.get(i), delRecursion);
			   }		  		
			}
	      }
		}
    static Map<Unit,LinkedList<Unit>> entryPaths=new LinkedHashMap<Unit,LinkedList<Unit>>();
    public static void callbackPath(){
    	List<String> visited=new ArrayList<String>();
		SootMethod dummyMain = null;
		for (SootMethod sm : methodOfPath.keySet()) {
			if (sm.toString().equals("<dummyMainClass: void dummyMainMethod()>")) {
				dummyMain = sm;
				break;
			}
		}
		List<Unit> dummyPath=methodOfPath.get(dummyMain);
		for (Unit pathNode : dummyPath){
			if(pathNode.getClass().toString().equals("class soot.jimple.internal.JInvokeStmt")||(pathNode.getClass().toString().equals("class soot.jimple.internal.JAssignStmt")
					&& pathNode.toString().matches(regEx)))
			if(visited.contains(pathNode.toString().substring(pathNode.toString().indexOf("<"), pathNode.toString().lastIndexOf(")>"))))
			{
				continue;
			}
//			System.out.println("回调："+pathNode);
			
			List<Unit> everyNodepath=new LinkedList<Unit>();
				SootMethod toFind = null;
				Collection<SootMethod> methodColls = iCfg.getCalleesOfCallAt(pathNode);
				for (SootMethod reserve : methodColls) {
					if (allMethod.contains(reserve)) {
						toFind = reserve;
						break;
					}
				}
				if (toFind != null && iCfg.isCallStmt(pathNode) && methodOfPath.keySet().contains(toFind)) {
				everyNodepath=methodOfPath.get(toFind);
				}
//				if(pathNode.toString().equals("virtualinvoke $r7.<com.airpush.android.DeliveryReceiver: void onReceive(android.content.Context,android.content.Intent)>(null, $r8)"))
//				{
//					System.out.println(x);
//				}
				
				if(!everyNodepath.isEmpty())
				{
				int times=0;
			  while(true){
				  times++;
				List<Unit> iterNew=new LinkedList<Unit>();
				boolean judge = false;
				boolean sumJudge = false;
//				System.out.println("后路径："+everyNodepath);
				for(Unit node:everyNodepath)
				{
			    judge=false;
			
				Collection<SootMethod> subMethodColls = iCfg.getCalleesOfCallAt(node);
				for (SootMethod subReserve : subMethodColls){
					  SootMethod subMethod = null;
					for(SootMethod sm:allMethod){
					  if(node.getClass().toString().equals("class soot.jimple.internal.JInvokeStmt")||(node.getClass().toString().equals("class soot.jimple.internal.JAssignStmt")&&node.toString().matches(regEx)))
					  {
						if(sm==subReserve){
							subMethod = subReserve;
							break;
						}
					  }
					}
					if (subMethod != null&& methodOfPath.keySet().contains(subMethod)) {
//						System.out.print("节点："+node);
//						System.out.println("方法："+subMethod);
//						System.out.println("找路："+methodOfPath.get(subMethod));
						iterNew.addAll(methodOfPath.get(subMethod));
						judge=true;
						sumJudge=true;
					}
				}
				if(judge==false){
//					System.out.println("节点："+node);
					iterNew.add(node);
				}
				}
				if(sumJudge==false){
					entryPaths.put(pathNode,new LinkedList<Unit>(iterNew));
					break;
				}	
				else{
				everyNodepath=new LinkedList<Unit>(iterNew);
				}
				if(times>10){
					entryPaths.put(pathNode,new LinkedList<Unit>(iterNew));
					break;
				}
				}
			}
			if(pathNode.getClass().toString().equals("class soot.jimple.internal.JInvokeStmt")||(pathNode.getClass().toString().equals("class soot.jimple.internal.JAssignStmt")
						&& pathNode.toString().matches(regEx)))
				visited.add(pathNode.toString().substring(pathNode.toString().indexOf("<"), pathNode.toString().lastIndexOf(")>")));
		}
		for(Unit unit:entryPaths.keySet()){
			System.out.println("回调："+unit);
			System.out.println("路径："+entryPaths.get(unit));
		}
	}
    public static Map<String,List<String>> allPermissionResult=new HashMap<String,List<String>>();
	public static Map<String,List<String>> allMethodResult=new HashMap<String,List<String>>();    
    public static Integer[] features;
    public static List<String> featuresLabel=new LinkedList<String>();
	public static void getFeature(){
		features=new Integer[classLoader.size()+systemCallback.size()+permissionAPI.size()+Cipher.size()+sensitiveAPI.size()+permission.size()+sourceAndSinks.size()];
		featuresLabel.addAll(classLoader);
		featuresLabel.addAll(systemCallback);
		featuresLabel.addAll(permissionAPI);
		featuresLabel.addAll(Cipher);
		featuresLabel.addAll(sensitiveAPI);
		featuresLabel.addAll(permission);
		featuresLabel.addAll(sourceAndSinks);
//		System.out.println("输出："+sourceAndSinks);
		for(int i=0;i<features.length;i++){
			features[i]=0;
//			System.out.println("i："+featuresLabel.get(i));
		}
		//定义以android.view开头模式的字符串，对驻点进行是否UI相关的判断
		for(Unit u:entryPaths.keySet()){
			
			boolean UI=false;
			Collection<SootMethod> entryColls=iCfg.getCalleesOfCallAt(u);
			for(SootMethod sm:entryColls){
  		   Chain<SootClass> getClasses=sm.getDeclaringClass().getInterfaces();
		   if(getClasses.isEmpty())
		   {
  		   getClasses.add(sm.getDeclaringClass().getSuperclass());
		   }
		  for(Iterator<SootClass> iterClass=getClasses.iterator();iterClass.hasNext();){
			  SootClass clas=iterClass.next();
		
			  if((clas.toString().contains("$")&&callbacks.contains(clas.toString().substring(0,clas.toString().indexOf("$"))))||!clas.toString().contains("$"))
			  {
				   if(clas.toString().contains("$")&&callbacks.contains(clas.toString().substring(0,clas.toString().indexOf("$")))){
					   UI=true;
				  }
				  else{
					  UI=false;
				  }
				   break;
			  }
			  else{
				    UI=false;
				  break;
			  }
		  }
		}
			for(Unit node:entryPaths.get(u))
			{	
		    if(node.getClass().toString().equals("class soot.jimple.internal.JInvokeStmt")||(node.getClass().toString().equals("class soot.jimple.internal.JAssignStmt")&&node.toString().matches(regEx)))
		    {
		    Collection<SootMethod> colls=iCfg.getCalleesOfCallAt(node);
		    if(!colls.isEmpty()){
			for(SootMethod sm:colls){
				String[] strArray=sm.toString().replace(": ", " ").split(" ");
				String packageName=strArray[0].substring(1);
				String methodName=strArray[2].substring(0,strArray[2].indexOf("("));	 
				String comStr=packageName+"->"+methodName;	
				if(permissionAPI.contains(comStr)){
					System.out.println(UI+"："+comStr);
					if(UI)
					{
					features[classLoader.size()+systemCallback.size()+permissionAPI.indexOf(comStr)]+=2;
					for(String perm:allMap.get(packageName).get(methodName))
					{
						System.out.println("权限："+perm);
					features[classLoader.size()+systemCallback.size()+permissionAPI.size()+Cipher.size()+sensitiveAPI.size()+permission.indexOf(perm)]+=2;
					}
				  }
					else{
						features[classLoader.size()+systemCallback.size()+permissionAPI.indexOf(comStr)]+=1;
						for(String perm:allMap.get(packageName).get(methodName))
						{
							System.out.println("权限："+perm);
						features[classLoader.size()+systemCallback.size()+permissionAPI.size()+Cipher.size()+sensitiveAPI.size()+permission.indexOf(perm)]+=1;
						}
					}
				}
//				if(!oneMethodResult.contains("1->"+node.toString()))
//					oneMethodResult.add("1->"+node.toString());
//					List<String> permissions=allMap.get(packageName).get(methodName);
//					for(String perm:permissions)
//					{
//					if(!onePermissionResult.contains(perm))
//						onePermissionResult.add(perm);
//					}
				
				
//				else if(compStart.contains(comStr)||classLoader.contains(packageName)||Cipher.contains(comStr)||sensitiveAPI.contains(comStr)){
//				if(!oneMethodResult.contains(node.toString()))
//					{
//				else if(compStart.contains(comStr))
//					oneMethodResult.add("2->"+node.toString());
				if(classLoader.contains(packageName))
				{
					System.out.println(UI+"："+packageName);
//					System.out.println("到这里classLoader:"+comStr);
					if(UI)
					{
					features[classLoader.indexOf(packageName)]+=2;
					}
					else{
					features[classLoader.indexOf(packageName)]+=1;	
					}
				}
//			oneMethodResult.add("3->"+node.toString());					
				if(Cipher.contains(comStr))
				{
					System.out.println(UI+"："+comStr);
//					System.out.println("到这里Cipher:"+comStr);
					if(UI)
					{
					features[classLoader.size()+systemCallback.size()+permissionAPI.size()+Cipher.indexOf(comStr)]+=2;
					}
					else
					{
					features[classLoader.size()+systemCallback.size()+permissionAPI.size()+Cipher.indexOf(comStr)]+=1;	
					}
//					oneMethodResult.add("4->"+node.toString());
				}
				if(sensitiveAPI.contains(comStr))
				{
					System.out.println(UI+"："+comStr);
//					System.out.println("到这里sensitiveAPI:"+comStr);
					if(UI)
					{
					features[classLoader.size()+systemCallback.size()+permissionAPI.size()+Cipher.size()+sensitiveAPI.indexOf(comStr)]+=2;
					}
					else{
					features[classLoader.size()+systemCallback.size()+permissionAPI.size()+Cipher.size()+sensitiveAPI.indexOf(comStr)]+=1;
					}
//					oneMethodResult.add("5->"+node.toString());
				}
				if(sourceAndSinks.contains(comStr))
				{
					System.out.println(UI+"："+comStr);
					if(UI)
					{
					features[classLoader.size()+systemCallback.size()+permissionAPI.size()+Cipher.size()+sensitiveAPI.indexOf(comStr)+permission.size()+sourceAndSinks.indexOf(comStr)]+=2;
					}
					else{
					features[classLoader.size()+systemCallback.size()+permissionAPI.size()+Cipher.size()+sensitiveAPI.indexOf(comStr)+permission.size()+sourceAndSinks.indexOf(comStr)]+=1;
					}	
				}
//				if()
			    }
//				}
//			 }
		  }
		  else{
			  String[] strArray=node.toString().substring(node.toString().indexOf("<"),node.toString().indexOf(">")).replace(": "," ").split(" ");
			  String packageName=strArray[0].substring(1);
			  String methodName=strArray[2].substring(0,strArray[2].indexOf("("));	 
			  String comStr=packageName+"->"+methodName;		
//			  if(comStr.equals("org.apache.http.impl.client.DefaultHttpClient->execute"))
//					System.out.println("有这个："+node);
			  if(permissionAPI.contains(comStr)){
//					System.out.println("到这里permissionAPI:"+comStr);
					System.out.println(UI+"："+comStr);
				  if(UI)
					{
					features[classLoader.size()+systemCallback.size()+permissionAPI.indexOf(comStr)]+=2;
					for(String perm:allMap.get(packageName).get(methodName))
					{
						System.out.println("权限："+comStr);
					features[classLoader.size()+systemCallback.size()+permissionAPI.size()+Cipher.size()+sensitiveAPI.size()+permission.indexOf(perm)]+=2;
					}
				  }
					else{
						features[classLoader.size()+systemCallback.size()+permissionAPI.indexOf(comStr)]+=1;
						for(String perm:allMap.get(packageName).get(methodName))
						{
							System.out.println("权限："+comStr);
						features[classLoader.size()+systemCallback.size()+permissionAPI.size()+Cipher.size()+sensitiveAPI.size()+permission.indexOf(perm)]+=1;
						}
					}
				}
				if(classLoader.contains(packageName))
				{
					System.out.println(UI+"："+packageName);
//					System.out.println("到这里classLoader:"+comStr);
					if(UI)
					{
					features[classLoader.indexOf(packageName)]+=2;
					}
					else{
					features[classLoader.indexOf(packageName)]+=1;	
					}
				}				
				if(Cipher.contains(comStr))
				{
					System.out.println(UI+"："+comStr);
//					System.out.println("到这里Cipher:"+comStr);
					if(UI)
					{
					features[classLoader.size()+systemCallback.size()+permissionAPI.size()+Cipher.indexOf(comStr)]+=2;
					}
					else
					{
					features[classLoader.size()+systemCallback.size()+permissionAPI.size()+Cipher.indexOf(comStr)]+=1;	
					}
				}
				if(sensitiveAPI.contains(comStr))
				{
					System.out.println(UI+"："+comStr);
//					System.out.println("到这里sensitiveAPI:"+comStr);
					if(UI)
					{
					features[classLoader.size()+systemCallback.size()+permissionAPI.size()+Cipher.size()+sensitiveAPI.indexOf(comStr)]+=2;
					}
					else{
					features[classLoader.size()+systemCallback.size()+permissionAPI.size()+Cipher.size()+sensitiveAPI.indexOf(comStr)]+=1;
					}
				}
		    }
		}
	}
//			if(onePermissionResult.size()>1)
//			{
//			allPermissionResult.put(u.toString(),new ArrayList<String>(onePermissionResult));
//			}
//			if(oneMethodResult.size()>1)
//			{
//			allMethodResult.put(u.toString(),new ArrayList<String>(oneMethodResult)); 
//			}
		}
//		for(String str:allMethodResult.keySet()){
//			System.out.println("主键："+str);
//			System.out.println("对值："+allMethodResult.get(str));
//		}
    }
    public static List<String> systemCallback=new LinkedList<String>();
    public static void systemCallback() throws Exception{
   		 FileReader fileReader = new FileReader(new File("H:\\System_callback.txt"));
   	        BufferedReader bufferedReader = new BufferedReader(fileReader);
   	       	String readLine = null;
   	      while ((readLine = bufferedReader.readLine()) != null) {
   	    	systemCallback.add(readLine.trim());
   	        } 
   	 }
    public static List<String> Cipher=new LinkedList<String>();
    public static void Cipher() throws Exception{
   		 FileReader fileReader = new FileReader(new File("H:\\crypto_Cipher.txt"));
   	        BufferedReader bufferedReader = new BufferedReader(fileReader);
   	       	String readLine = null;
   	      while ((readLine = bufferedReader.readLine()) != null) {
   	    	if(!readLine.isEmpty())
   	    	{
   	    	  Cipher.add(readLine.trim());
   	    	}
   	        } 
   	 }
    public static void MenifestChecker(){
    
    	ProcessManifest processManifest;
//      	String filepath="I:\\雷倩U盘\\另一台电脑\\E盘\\成果汇总\\好心人分享的样本集\\OneDrive-2019-01-13\\drebin-5\\7a050d59c1044a4873763e7371160a16ec5904dc3be4392aa65f6291a6d1e95f.apk";
    	String filepath="H:\\雷倩U盘\\另一台电脑\\E盘\\成果汇总\\好心人分享的样本集\\OneDrive-2019-01-13\\Opfake\\f56edec6e83bb7fdcab13ceaa14c6129f6c2652f64ad21e2f54b5c5d8c72c00e.apk";
    	List<List<String>> attributes=new ArrayList<List<String>>();
  				try {
  					processManifest = new ProcessManifest(filepath);
  					ArrayList<AXmlNode> lists0 = processManifest.getActivities();
  					for(AXmlNode xml:lists0){
  					
  						List<String> attribute=new ArrayList<String>();
  						attribute.add(xml.toString().substring(1,xml.toString().indexOf(" "))+"->"+xml.getAttribute("name").toString());
  						for(AXmlNode filter:xml.getChildren()){
  							if(filter.toString().contains("<intent-filter>"))
  							{
  							for(AXmlNode action:filter.getChildren())
  							{
  							
  						 if(action.toString().indexOf("<action")==0)
  						   {
  								attribute.add(action.toString().substring(1,action.toString().indexOf(" "))+"->"+action.getAttribute("name").toString());
  						   }
  						 }
  					   }
  					}
  						attributes.add(new ArrayList<String>(attribute));
  					}
  					ArrayList<AXmlNode> lists1 = processManifest.getServices();
  					for(AXmlNode xml:lists1){
  						List<String> attribute=new ArrayList<String>();
  						attribute.add(xml.toString().substring(1,xml.toString().indexOf(" "))+"->"+xml.getAttribute("name").toString());
  						for(AXmlNode filter:xml.getChildren()){
  							if(filter.toString().contains("<intent-filter>"))
  							{
  							for(AXmlNode action:filter.getChildren())
  							{	
  						 if(action.toString().indexOf("<action")==0)
  						 {
  							attribute.add(action.toString().substring(1,action.toString().indexOf(" "))+"->"+action.getAttribute("name").toString());
  						 }	
  						 }
  							}
  						}
  						attributes.add(new ArrayList<String>(attribute));
  					}
  					ArrayList<AXmlNode> lists2 = processManifest.getReceivers();
  					for(AXmlNode xml:lists2){
  						List<String> attribute=new ArrayList<String>();
  						attribute.add(xml.toString().substring(1,xml.toString().indexOf(" "))+"->"+xml.getAttribute("name").toString());
  						for(AXmlNode filter:xml.getChildren()){
  							if(filter.toString().contains("<intent-filter>"))
  							{
  							for(AXmlNode action:filter.getChildren())
  							{			
  						     if(action.toString().indexOf("<action")==0)
  						     {
  							attribute.add(action.toString().substring(1,action.toString().indexOf(" "))+"->"+action.getAttribute("name").toString());
  						     }
  						     }
  							}
  						}
  						attributes.add(new ArrayList<String>(attribute));
  					}
  					List<List<String>> attrToMethod=new ArrayList<List<String>>();
  					List<String> oneToMethod=new ArrayList<String>();
  					for(List<String> attribute:attributes)
  					{	
  					if(attribute.size()>1)
  					{ 						
  						if(systemCallback.contains(attribute.get(1))){
  							features[classLoader.size()+systemCallback.indexOf(attribute.get(1))]=2;
//  						if(attribute.get(0).indexOf("receiver")==0){
//  							
//  							for(String callMethod:allMethodResult.keySet()){
//  							  if(callMethod.contains(attribute.get(0).substring(attribute.get(0).indexOf("=\"")+2,attribute.get(0).indexOf("\"", attribute.get(0).indexOf("=\"")+2))+": void onReceive")){
//  								oneToMethod.add(attribute.get(1).substring(attribute.get(1).indexOf("=\"")+2,attribute.get(1).indexOf("\"",attribute.get(0).indexOf("=\"")+2)));
//  								oneToMethod.add(callMethod);
//  								oneToMethod.addAll(allMethodResult.get(callMethod));
//  								break;
//  								}
//  							}
//  						}
  					
//  						if(attribute.get(0).indexOf("service")==0){
//  							for(String callMethod:allMethodResult.keySet()){
//  								boolean judge=false;
//  								if(callMethod.contains(attribute.get(0).substring(attribute.get(0).indexOf("=\"")+2,attribute.get(0).indexOf("\"", attribute.get(0).indexOf("=\"")+2))+": void onCreate")
//    									  ||callMethod.contains(attribute.get(0).substring(attribute.get(0).indexOf("=\"")+2,attribute.get(0).indexOf("\"", attribute.get(0).indexOf("=\"")+2))+": void onStart")
//    									  ||callMethod.contains(attribute.get(0).substring(attribute.get(0).indexOf("=\"")+2,attribute.get(0).indexOf("\"", attribute.get(0).indexOf("=\"")+2))+": void onStartCommand")){
//    								  oneToMethod.add(attribute.get(1).substring(attribute.get(1).indexOf("=\"")+2,attribute.get(1).indexOf("\"",attribute.get(0).indexOf("=\"")+2)));
//    								  oneToMethod.add(callMethod);
//    								  oneToMethod.addAll(allMethodResult.get(callMethod));					
//    							judge=true;	
//  								}
//  								if(judge==true)
//  								{
//  								attrToMethod.add(new ArrayList<String>(oneToMethod));
//  		  						oneToMethod.clear();
//  								}  	
//    						}
//  						}
  						
  						}
  					}
  					}
//  					for(List<String> str:attrToMethod){
//  						System.out.println("输出："+str);
//  					}
  				} catch (IOException | XmlPullParserException e) {
  					// TODO Auto-generated catch block
  					e.printStackTrace();
  				}
  			
}
}
