package com.example.rxb;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class DsfCycle {
	static boolean hasCycle = false;
	static Set<Integer> searched = new HashSet<>();
	static List<List<Integer>> allCycle = new ArrayList<List<Integer>>();
	static List<Integer> trace = new ArrayList<>();
	static ArrayList<map2> complex = new ArrayList<map2>();
	static Map<String, otherMap2> otherComplex = new HashMap<String, otherMap2>();
	static ArrayList<map2> filterComplex = new ArrayList<map2>();
	static ArrayList<map2> preparedComplex = new ArrayList<map2>();
	static List<List<Integer>> headSubLoopArray = new ArrayList<List<Integer>>();
	static List<List<Integer>> tailSubLoopArray = new ArrayList<List<Integer>>();
	static List<List<Integer>> dealedHeadSubLoopArray = new ArrayList<List<Integer>>();
	static List<List<Integer>> dealedTailSubLoopArray = new ArrayList<List<Integer>>();
	static List<Integer> replace = new ArrayList<Integer>();
	static List<Integer> allCycleNumber = new ArrayList<Integer>();
	static List<List<Integer>> restSimpleCycle = new ArrayList<List<Integer>>();
	static Map<String, List<List<Integer>>> andAllLast = new HashMap<String, List<List<Integer>>>();
	static Map<String, List<Integer>> allLast = new HashMap<String, List<Integer>>();
	static Map<List<Integer>, Map<String, List<String>>> andCycleNumber = new HashMap<List<Integer>, Map<String, List<String>>>();
	static List<Integer> andNumber = new ArrayList<Integer>();
	private static int[] visited;//节点状态,值为0的是未访问的
	static int[][] en;
	static int n;
	public static void deliver(int[][] e,int elength) {
//		CFGGraph graph = getDirectedGraph.getGraph();
	     en = e;
		 n = elength;
		 visited=new int[n];
         Arrays.fill(visited,0);
//         for (int i = 0; i < n; i++) {
// 			if (searched.contains(i))
// 				continue;
 			findCycle(0,en);
 			System.out.println("环："+allCycle.size());
// 		}
 		deleteDifferentSequenceSameCycle();
	}
//		for (int i = 0; i < n; i++) {
//			if (searched.contains(i))
//				continue;
//			findCycle(i, e);
//		}
//		deleteDifferentSequenceSameCycle();
//		
//		Iterator<List<Integer>> its = allCycle.iterator();
//		while (its.hasNext()) {
//			List<Integer> list = its.next();
//			if (list.toString().equals(replace.toString())) {
//				its.remove();
//			}
//		}
//        for(List<Integer> resave:allCycle){
//			
//			System.out.println("剩余环："+resave);
//		}
//		dealCycle1();// 对于并环和子环组成对
//		getSingle();// 去掉重复的（不知道有用没有）
//		getsubLoopCycle2();// 获得彻头彻尾的子环和完整环
//		dealSameHeadCycle3();// 处理同头（同尾或不同尾的环）
//		dealDifferHeadLoop4();// 处理不同头但同尾的环
//		dealHeadToTailCycle5();// 处理环头等于环尾的环对
//		dealIndependenceLoop6();// 处理既不是子环又不同头又不同尾的环
//	}
	static void findCycle(int v, int[][] e) {
		int j = trace.indexOf(v);
		if (j != -1) {
			hasCycle = true;
			List<Integer> circle = new ArrayList<>();
//			 System.out.print("Cycle:");
			while (j < trace.size()) {
//				 System.out.print(trace.get(j)+1);
//				 System.out.print(" ");
				circle.add((trace.get(j)));
				allCycleNumber.add(trace.get(j));
				j++;
			}
//			 System.out.println("");
			if (!allCycle.contains(circle)) {
				allCycle.add(circle);
			}
			return;
		}
		trace.add(v);
		for (int i = 0; i < e.length; i++) {
			if (e[v][i] == 1) {
				searched.add(i);
				findCycle(i, e);
			}
		}
		trace.remove(trace.size() - 1);
	}
//	 static void findCycle(int v)   //递归DFS
//	    {
//	        if(visited[v]==1)
//	        {
//	            int j;
//	            if((j=trace.indexOf(v))!=-1)
//	            {
//	                hasCycle=true;
////	                System.out.print("Cycle:");
//	                while(j<trace.size())
//	                {
////	                    System.out.print(trace.get(j)+" ");
//	                    j++;
//	                }
////	                System.out.print("\n");
//	                return;
//	            }
//	            return;
//	        }
//	        visited[v]=1;
//	        trace.add(v);
//
//	        for(int i=0;i<n;i++)
//	        {
//	            if(en[v][i]==1)
//	                findCycle(i);
//	        }
//	        trace.remove(trace.size()-1);
//	    }
	public boolean getHasCycle() {
		return hasCycle;
	}

	public static boolean equals(List<Integer> iCycle, List<Integer> jCycle) {
		for (int m = 0; m < iCycle.size(); m++) {
			if (iCycle.get(m) != jCycle.get(m)) {
				return false;
			}
		}
		return true;
	}

	public static void deleteDifferentSequenceSameCycle() {
		replace.add(0);
		for (int i = 0; i < allCycle.size() - 1; i++) {
			if (!allCycle.get(i).toString().equals(replace.toString())) {
				for (int j = i + 1; j < allCycle.size(); j++) {
					if (!allCycle.get(j).toString().equals(replace.toString())) {
						Integer[] same1 = new Integer[allCycle.get(i).size()];
						allCycle.get(i).toArray(same1);
						Integer[] same2 = new Integer[allCycle.get(j).size()];
						allCycle.get(j).toArray(same2);
						if (same1.length == same2.length) {
							boolean judge = judgeSame(same1, same2);
							if (judge)
								allCycle.set(j, new ArrayList<Integer>(replace));
						}
					}
				}
			}
		}
		for(Iterator<List<Integer>> iter=allCycle.iterator();iter.hasNext();){
			List<Integer> get=iter.next();
			if(get.equals(replace)){
				iter.remove();
			}
		}
	}

	public static boolean judgeSame(Integer[] same1, Integer[] same2) {

		Integer[] compare1 = same1.clone();
		Integer[] compare2 = same2.clone();
		Arrays.sort(compare1);
		Arrays.sort(compare2);
		if (!Arrays.equals(compare1, compare2)) {
			return false;
		} else {
			return true;
		}
	}

	public static void dealCycle1() {
		for (List<Integer> subCycle : allCycle) {
			for (List<Integer> longCycle : allCycle) {
				if (longCycle.size() >= subCycle.size() && !longCycle.equals(subCycle)) {
					// 短环路是长环路的子环
					Integer[] longNumbers = new Integer[longCycle.size()];
					longCycle.toArray(longNumbers);
					Integer[] subNumbers = new Integer[subCycle.size()];
					subCycle.toArray(subNumbers);
					if (ifInclude(subNumbers, longNumbers)) {
						complex.add(new map2("subLoop", new ArrayList<Integer>(subCycle),
								new ArrayList<Integer>(longCycle)));
					}
					// 环路的头一样，尾一样
					// 环路的头一样，尾不一样，并且不是子环，环路的头不一样，尾一样的情况雷同
					if (longCycle.get(0).equals(subCycle.get(0))
							&& longCycle.get(longCycle.size() - 1).equals(subCycle.get(subCycle.size() - 1))
							|| (!ifInclude(subNumbers, longNumbers) && longCycle.get(0).equals(subCycle.get(0))
									&& !longCycle.get(longCycle.size() - 1)
											.equals(subCycle.get(subCycle.size() - 1)))) {
						complex.add(new map2("sameHeadLoop", new ArrayList<Integer>(subCycle),
								new ArrayList<Integer>(longCycle)));
					}
					// 长环路的头是短环路的尾
					if (longCycle.get(0) == subCycle.get(subCycle.size() - 1)) {
						complex.add(new map2("headToTailLoop", new ArrayList<Integer>(subCycle),
								new ArrayList<Integer>(longCycle)));
					}
					// 短环路的头是长环路的尾
					if (subCycle.get(0) == longCycle.get(longCycle.size() - 1)) {
						complex.add(new map2("headToTailLoop", new ArrayList<Integer>(longCycle),
								new ArrayList<Integer>(subCycle)));
					}
				}
			}
		}
	}

	public static boolean ifInclude(Integer[] a, Integer[] b) {
		boolean flag = false;
		int sign = 0;
		for (int i = 0; i < b.length; i++) {
			sign = 0;
			int k = i;
			for (int j = 0; j < a.length; j++) {
				if (k < b.length) {
					if (b[k] == a[j]) {
						sign = sign + 1;
						k++;
						flag = true;
						continue;
					} else {
						flag = false;
						break;
					}
				} else {
					break;
				}
			}
			if (flag == true) {
				break;
			}
		}
		if (sign == a.length && flag == true)
			return true;
		else
			return false;
	}
	// 用于去除（complex中重复的元素）
	public static void getSingle() {
		// 1.创建新集合
		Iterator<map2> it = complex.iterator(); // 2.根据传入的集合（老集合）获取迭代器
		while (it.hasNext()) { // 3.遍历老集合
			map2 map = it.next(); // 记录住每一个元素
			if (!(filterComplex.contains(map))) { // 如果新集合中不包含老集合中的元素
				filterComplex.add(map); // 将该元素进行添加
				preparedComplex.add(new map2(new String(map.keyStr), new ArrayList<Integer>(map.head),
						new ArrayList<Integer>(map.tail)));
			}
		}
	}

	public static boolean equalList(List<Integer> list1, List<Integer> list2) {

		if (list1.size() != list2.size())

			return false;

		if (list2.containsAll(list1) && list1.containsAll(list2))

			return true;

		return false;

	}

	static map2[] saveDealedSubLoopArray;

	public static void getsubLoopCycle2() {
		ArrayList<map2> saveSubLoop = new ArrayList<map2>();
		for (map2 m : filterComplex) {
			if (m.keyStr.equals("subLoop")) {
				saveSubLoop.add(new map2(m.keyStr, m.head, m.tail));
			}
		}
		map2[] saveSubLoopArray = new map2[saveSubLoop.size()];
		saveSubLoop.toArray(saveSubLoopArray);
		// 排序
		for (int i = saveSubLoopArray.length - 1; i > 0; i--) {// 让比较的范围不停的减掉最后一个单元
			for (int j = 1; j <= i; j++) {
				int pre = saveSubLoopArray[j - 1].head.size() + saveSubLoopArray[j - 1].tail.size();
				int bac = saveSubLoopArray[j].head.size() + saveSubLoopArray[j].tail.size();
				if (pre > bac) {// 让2个数之间大的数排后面
					map2 temp = saveSubLoopArray[j - 1];
					saveSubLoopArray[j - 1] = saveSubLoopArray[j];
					saveSubLoopArray[j] = temp;
				}
			}
		}
		List<map2> prepareForDR1 = Arrays.asList(saveSubLoopArray);
		ArrayList<map2> prepareForDR = new ArrayList<map2>(prepareForDR1);
		// 删除那些尾一样，一个是另一个的子环的map2对。
		if (prepareForDR != null && prepareForDR.size() > 0) {
			// 上短下长
			for (int i = 0; i < prepareForDR.size(); i++) {
				if (prepareForDR.get(i).keyStr.equals("subLoop")) {
					for (int j = 0; j < prepareForDR.size(); j++) {
						if (prepareForDR.get(j).keyStr.equals("subLoop")) {
							int pre = prepareForDR.get(i).head.size() + prepareForDR.get(i).tail.size();
							int bac = prepareForDR.get(j).head.size() + prepareForDR.get(j).tail.size();
							if (pre < bac) {
								Integer[] subNumbers = new Integer[prepareForDR.get(i).head.size()];
								prepareForDR.get(i).head.toArray(subNumbers);
								Integer[] longNumbers = new Integer[prepareForDR.get(j).head.size()];
								prepareForDR.get(j).head.toArray(longNumbers);
								if (equalList(prepareForDR.get(i).tail, prepareForDR.get(j).tail)
										&& ifInclude(subNumbers, longNumbers)) {
									prepareForDR.set(i, new map2("useless", null, null));
									break;
								}
							}
						}
					}
				}
			}
		}
		Iterator<map2> it = prepareForDR.iterator();
		while (it.hasNext()) {
			map2 x = it.next();
			if (x.keyStr.equals("useless")) {
				it.remove();
			}
		}
		saveDealedSubLoopArray = new map2[prepareForDR.size()];
		for (int i = 0; i < prepareForDR.size(); i++) {
			saveDealedSubLoopArray[i] = new map2(prepareForDR.get(i).keyStr, prepareForDR.get(i).head,
					prepareForDR.get(i).tail);
		}
		saveSubLoopArray = new map2[prepareForDR.size()];
		prepareForDR.toArray(saveSubLoopArray);
		for (int i = 0; i < saveSubLoopArray.length; i++) {
			headSubLoopArray.add(saveSubLoopArray[i].head);
			tailSubLoopArray.add(saveSubLoopArray[i].tail);
		}
		// 经过处理的彻头彻尾
		for (int i = 0; i < headSubLoopArray.size(); i++) {
			if (!tailSubLoopArray.contains(headSubLoopArray.get(i))
					&& !dealedHeadSubLoopArray.contains(headSubLoopArray.get(i))) {
				dealedHeadSubLoopArray.add(headSubLoopArray.get(i));
			}
		}
		for (int i = 0; i < tailSubLoopArray.size(); i++) {
			if (!headSubLoopArray.contains(tailSubLoopArray.get(i))
					&& !dealedTailSubLoopArray.contains(tailSubLoopArray.get(i))) {
				dealedTailSubLoopArray.add(tailSubLoopArray.get(i));
			}
		}
		// System.out.println("处理的尾长度："+dealedTailSubLoopArray.size());
		// for (int i = 0; i < dealedTailSubLoopArray.size(); i++) {
		// System.out.println("处理尾:"+dealedTailSubLoopArray.get(i));
		// }
	}

	static List<List<Integer>> SameHeadArray = new ArrayList<List<Integer>>();

	public static void dealSameHeadCycle3() {
		List<List<Integer>> differCycle = new ArrayList<List<Integer>>();
		// 处理后的环中环路径
		for (int i = 0; i < filterComplex.size(); i++) {
			if (filterComplex.get(i) != null) {
				differCycle.clear();
				if (filterComplex.get(i).keyStr.equals("sameHeadLoop")) {
					Integer match = filterComplex.get(i).head.get(0);
					if (!headSubLoopArray.contains(filterComplex.get(i).head)) {
						differCycle.add(filterComplex.get(i).head);
						SameHeadArray.add(filterComplex.get(i).head);

					}
					if (!headSubLoopArray.contains(filterComplex.get(i).tail)) {
						differCycle.add(filterComplex.get(i).tail);
						SameHeadArray.add(filterComplex.get(i).tail);
					}
					for (int j = i; j < filterComplex.size(); j++) {
						if (filterComplex.get(j) != null) {
							if (filterComplex.get(j).keyStr.equals("sameHeadLoop")) {
								if (filterComplex.get(j).head.get(0) == match) {
									if (!differCycle.contains(filterComplex.get(j).head)
											&& !headSubLoopArray.contains(filterComplex.get(j).head)) {
										differCycle.add(filterComplex.get(j).head);
										SameHeadArray.add(filterComplex.get(j).head);
									}
									if (!differCycle.contains(filterComplex.get(j).tail)
											&& !headSubLoopArray.contains(filterComplex.get(j).tail)) {
										differCycle.add(filterComplex.get(j).tail);
										SameHeadArray.add(filterComplex.get(j).tail);
									}
									filterComplex.set(j, null);
								}
							}
						}
					}
					if (!differCycle.isEmpty()) {
						dealAndCycleRedundance(differCycle);// 删除所有在别的环路中能表示出来的环路
						andAllLast.put(differCycle.get(0).get(0) + "->AndLoop",
								new ArrayList<List<Integer>>(differCycle));
//						System.out.println("并环：" + differCycle);

					}
				}
			}
		}
		for (List<Integer> list : SameHeadArray) {
			if (dealedTailSubLoopArray.contains(list)) {
				dealedTailSubLoopArray.remove(list);
			}
		}
		dealAndCycleRedundance(dealedTailSubLoopArray);
		// System.out.println("剩余的尾长度："+dealedTailSubLoopArray.size());
		for (List<Integer> str : dealedTailSubLoopArray) {
//			System.out.println("剩余的尾：" + str);
			allLast.put(str.get(0) + "->TailSubLoop", new ArrayList<Integer>(str));
		}
	}

	public static List<List<Integer>> differHeadArray = new ArrayList<List<Integer>>();

	public static void dealDifferHeadLoop4() {
		List<List<Integer>> back_allCycle = new ArrayList<List<Integer>>();
		for (List<Integer> back : allCycle) {
			back_allCycle.add(new ArrayList<Integer>(back));
		}
		for (int i = 0; i < back_allCycle.size() - 1; i++) {
			if (!headSubLoopArray.contains(back_allCycle.get(i)) && back_allCycle.get(i) != null) {
				boolean judge = false;
				int beginMatch = back_allCycle.get(i).get(0);
				int endMatch = back_allCycle.get(i).get(back_allCycle.get(i).size() - 1);
				otherMap2 om1 = new otherMap2("endWith" + endMatch);
				om1.addList(back_allCycle.get(i));
				for (int j = i + 1; j < back_allCycle.size(); j++) {
					if (!headSubLoopArray.contains(back_allCycle.get(j)) && back_allCycle.get(j) != null) {
						if (back_allCycle.get(j).get(back_allCycle.get(j).size() - 1).equals(endMatch)
								&& !back_allCycle.get(j).get(0).equals(beginMatch)) {
							if (!om1.comp.contains(new ArrayList<Integer>(back_allCycle.get(j)))) {
								judge = true;
								om1.addList(new ArrayList<Integer>(back_allCycle.get(j)));
							}
							back_allCycle.set(j, null);
						}
					}
				}
				if (judge == true) {
					differHeadArray.addAll(om1.comp);
					otherComplex.put("endWith" + endMatch, new otherMap2(om1));
				}
			}
		}
		// System.out.println("输出新的测试");
		for (String om2 : otherComplex.keySet()) {
			andAllLast.put(om2, otherComplex.get(om2).comp);
//			System.out.println("新的测试：" + om2 + " " + otherComplex.get(om2).comp);
		}
	}
	//filterCycle中要用的数据
	static Map<List<List<Integer>>, List<List<Integer>>> headToTailLast = new HashMap<List<List<Integer>>, List<List<Integer>>>();
	
	static List<String> removeFromAndAllLast = new ArrayList<String>();
	static List<List<Integer>> headToTailArray=new ArrayList<List<Integer>>();
    public static void dealHeadToTailCycle5() {
		List<Integer> VisitedHead = new ArrayList<Integer>();
		List<Integer> VisitedTail = new ArrayList<Integer>();
		for (int i = 0; i < filterComplex.size(); i++) {
			if (filterComplex.get(i) != null) {
				if (filterComplex.get(i).keyStr.equals("headToTailLoop")) {
					if (!headSubLoopArray.contains(filterComplex.get(i).head)
							&& !headSubLoopArray.contains(filterComplex.get(i).tail)) {
						int first = filterComplex.get(i).head.get(filterComplex.get(i).head.size() - 1);
						int end = filterComplex.get(i).tail.get(0);
						if (!VisitedHead.contains(first) && !VisitedTail.contains(end)) {
							if (andAllLast.containsKey(first + "->AndLoop")
									&& andAllLast.containsKey("endWith" + end)) {
								headToTailLast.put(new ArrayList<List<Integer>>(andAllLast.get(first + "->AndLoop")),
										new ArrayList<List<Integer>>(andAllLast.get("endWith" + end)));
								removeFromAndAllLast.add(first + "->AndLoop");
								removeFromAndAllLast.add("endWith" + end);
							} else if (andAllLast.containsKey(first + "->AndLoop")
									&& !andAllLast.containsKey("endWith" + end)) {
								List<List<Integer>> temp = new ArrayList<List<Integer>>();
								temp.add(filterComplex.get(i).tail);
								headToTailArray.add(filterComplex.get(i).tail);
								headToTailLast.put(new ArrayList<List<Integer>>(andAllLast.get(first + "->AndLoop")),
										new ArrayList<List<Integer>>(temp));
								removeFromAndAllLast.add(first + "->AndLoop");
							} else if (!andAllLast.containsKey(first + "->AndLoop")
									&& andAllLast.containsKey("endWith" + end)) {
								List<List<Integer>> temp = new ArrayList<List<Integer>>();
								temp.add(filterComplex.get(i).head);
								headToTailArray.add(filterComplex.get(i).head);
								headToTailLast.put(new ArrayList<List<Integer>>(temp),
										new ArrayList<List<Integer>>(andAllLast.get("endWith" + end)));
								removeFromAndAllLast.add("endWith" + end);
							} else {
								List<List<Integer>> temp1 = new ArrayList<List<Integer>>();
								temp1.add(filterComplex.get(i).head);
								headToTailArray.add(filterComplex.get(i).head);
								List<List<Integer>> temp2 = new ArrayList<List<Integer>>();
								temp2.add(filterComplex.get(i).tail);
								headToTailArray.add(filterComplex.get(i).tail);
								headToTailLast.put(new ArrayList<List<Integer>>(temp1),
										new ArrayList<List<Integer>>(temp2));
							}
							VisitedHead.add(first);
							VisitedTail.add(end);
						}
					}
				}
			}
		}
		for(List<List<Integer>> out:headToTailLast.keySet()){
			System.out.println("尾对头："+out+" "+headToTailLast.get(out));
		}
		for (String str : removeFromAndAllLast) {
			andAllLast.remove(str);
		}
		for(String str:andAllLast.keySet()){
			System.out.println("剩并环："+str+" "+andAllLast.get(str));
		}
	}

	public static List<List<Integer>> IndependenceArray = new ArrayList<List<Integer>>();

	public static void dealIndependenceLoop6() {
		for (List<Integer> idep : allCycle) {
			if (!headSubLoopArray.contains(idep) && !SameHeadArray.contains(idep) && !differHeadArray.contains(idep)&&!headToTailArray.contains(idep)) {
				IndependenceArray.add(idep);
				System.out.println("独立环：" + idep);
			}
		}
	}

		public static void dealAndCycleRedundance(List<List<Integer>> listListArray) {
		List<Integer> replace = new ArrayList<Integer>();
		boolean finalJudge = true;
		for (int m = 0; m < listListArray.size(); m++) {
			if (!listListArray.get(m).equals(replace)) {
				for (int n = 0; n < listListArray.size(); n++) {
					if (!listListArray.get(n).equals(replace)) {
						if (listListArray.get(m).size() > listListArray.get(n).size()) {
							List<List<Integer>> restNumber = new ArrayList<List<Integer>>();
							if (listListArray.get(m).containsAll(listListArray.get(n))) {
								int k = 0;
								boolean judge = false;
								List<Integer> test = new ArrayList<Integer>();
								for (int i = 0; i < listListArray.get(m).size(); i++) {

									if (listListArray.get(m).get(i) == listListArray.get(n).get(k)) {
										judge = true;
										if (!test.isEmpty() && !restNumber.contains(new ArrayList<Integer>(test))) {

											restNumber.add(new ArrayList<Integer>(test));
										}
										k++;
										continue;
									} else {
										if (judge == true) {
											test.clear();
											test.add(listListArray.get(m).get(i));
										}
										if (judge == false) {
											test.add(listListArray.get(m).get(i));
										}
										judge = false;
									}
								}
								finalJudge = true;
								for (List<Integer> list : restNumber) {
									if (allCycle.contains(list)) {
										continue;
									} else {
										finalJudge = false;
										break;
									}
								}
								if (finalJudge == true) {
									listListArray.set(n, replace);
								}
							}
						}
					}
				}
			}
		}
		for (Iterator<List<Integer>> iter = listListArray.iterator(); iter.hasNext();) {
			List<Integer> will = iter.next();
			if (will.equals(replace)) {
				iter.remove();
			}
		}
	}

}
