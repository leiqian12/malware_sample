package com.example.rxb;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;

import soot.MethodOrMethodContext;
import soot.PatchingChain;
import soot.SootMethod;
import soot.Unit;
import soot.jimple.infoflow.Infoflow;
import soot.jimple.infoflow.android.TestApps.Test;
import soot.jimple.infoflow.solver.IInfoflowCFG;
import soot.jimple.toolkits.callgraph.Edge;
import soot.toolkits.graph.DirectedGraph;
import soot.util.HashChain;

public class getDirectedGraph {
	static int sumBegin=0;
	static int sumEnd=0;
	static Infoflow info = new Infoflow();
	public static IInfoflowCFG iCfg;
	static NewDirectedGraph newDG;
	static List<NewDirectedGraph> newDGList=new ArrayList<NewDirectedGraph>();
	static String regEx = "^.*[a-zA-Z]*[\\(]{1}.*[\\)]$";
	protected static List<Unit> dummyHeads = new ArrayList<Unit>();
	protected static List<Unit> dummyTails = new ArrayList<Unit>();
	protected static Map<SootMethod, List<Unit>> heads = new HashMap<SootMethod, List<Unit>>();
	protected static Map<SootMethod, List<Unit>> tails = new HashMap<SootMethod, List<Unit>>();;
	protected static Map<Unit, ArrayList<Unit>> unitToSuccs = new HashMap<Unit, ArrayList<Unit>>();
	protected static Map<Unit, ArrayList<Unit>> unitToPreds = new HashMap<Unit, ArrayList<Unit>>();
	static HashMap<Unit,List<Unit>>selfToSuccess=new HashMap<Unit,List<Unit>>();
	static ArrayList<Queue<Unit>> paths=new ArrayList<Queue<Unit>>();
	public static int dummyMainIndex=0;
	 static List<Vertex> labelVertex=new ArrayList<Vertex>();
	 static List<MethodOrMethodContext> visitedVertex=new ArrayList<MethodOrMethodContext>();
	 static Edge[] edgeArray;
	 static Vertex[] vertexArray;
	 static Map<SootMethod,List<Vertex>> smToVertex=new HashMap<SootMethod,List<Vertex>>();
	static SootMethod dummy;
	public static Set<Edge> edges=new HashSet<Edge>();
	public static CFGGraph graph;
	public static void getGraph() {
		try {
			Test.runAnalysis("E:\\period\\测试样本\\normal\\工具(tools)\\com.gisinnov.wifishare_4.apk","F:/leiqian/adt-bundle-windows-x86-20130729/sdk/platforms/");
		} catch (Exception e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		iCfg = Test.iCfg;
		edges=Test.cg.edges;
		for(Iterator<Edge> iterEdges=edges.iterator();iterEdges.hasNext();){
			Edge edge=iterEdges.next();
			if(edge.getTgt().toString().contains("<init>")||edge.getTgt().toString().contains("<clinit>")){
				iterEdges.remove();
			}
		}
       for(Edge e:edges){
         if(!visitedVertex.contains(e.getSrc())){
        	 if(e.getSrc().toString().equals("<dummyMainClass: void dummyMainMethod()>")){
        		 dummy=e.getSrc().method();
        	 }
	      labelVertex.add(new Vertex(e.getSrc()));
	      visitedVertex.add(e.getSrc());
       }
        if(!visitedVertex.contains(e.getTgt().method())){
	     labelVertex.add(new Vertex(e.getTgt()));
	     visitedVertex.add(e.getTgt());
      }
   }
      edgeArray=new Edge[edges.size()];
      vertexArray=new Vertex[labelVertex.size()];
      graph=new CFGGraph(labelVertex.toArray(vertexArray),edges.toArray(edgeArray));
      dummyMainIndex=CFGGraph.findIndex(dummy, vertexArray);
//      System.out.println("文件数："+info.getMethodsForSeeds(iCfg).size());
      for (SootMethod sm : info.getMethodsForSeeds(iCfg)) {   	  
			int methodSize = 0;
			PatchingChain<Unit> unitChain = new PatchingChain<Unit>(new HashChain<Unit>());
			if (sm.hasActiveBody() && sm.getDeclaringClass().isConcrete()
				&& !sm.getDeclaringClass().isJavaLibraryClass() && !sm.toString().equals("<dummyMainClass: void dummyMainMethod()>")) {
                 
				DirectedGraph<Unit> dg = iCfg.getOrCreateUnitGraph(sm);				
//				System.out.println("过滤前方法："+sm);
				for (Iterator<Unit> units = dg.iterator(); units.hasNext();) {
					Unit u = units.next();
//					System.out.println(u);
					if (!(u.getClass().toString().equals("class soot.jimple.internal.JInvokeStmt")
							|| (u.getClass().toString().equals("class soot.jimple.internal.JAssignStmt")
									&& u.toString().matches(regEx))
							|| dg.getHeads().contains(u) || dg.getTails().contains(u))
							|| (u.getClass().toString().equals("class soot.jimple.internal.JInvokeStmt")
									&& u.toString().contains(": void <init>("))) {
						List<Unit> Preds = new ArrayList<Unit>(dg.getPredsOf(u));
						List<Unit> Succs = new ArrayList<Unit>(dg.getSuccsOf(u));
//						List<Unit> Preds = new ArrayList<Unit>(u.getPreds());
//						List<Unit> Succs = new ArrayList<Unit>(u.getSuccs());
						/* 对于每一个前驱节点，都加上新的后继节点 */
						for (Unit pred : Preds) {
							dg.getSuccsOf(pred).remove(u);
//							pred.removeSuccs(u);
							for (Unit succ : Succs) {
								if(!dg.getSuccsOf(pred).contains(succ)){
//								if (!pred.getSuccs().contains(succ)) {
//									pred.addSuccs(succ);
									dg.getSuccsOf(pred).add(succ);
								}
							}
            		}

						/* 对于每一个后继节点，都加上新的前驱节点 */
						for (Unit succ : Succs) {
							dg.getPredsOf(succ).remove(u);
//							succ.removePreds(u);
							for (Unit pred : Preds) {
//								if (!succ.getPreds().contains(pred)) {
//									succ.addPreds(pred);
								if(!dg.getPredsOf(succ).contains(pred)){
									dg.getPredsOf(succ).add(pred);
								}
							}
						}
//						dg.iterator().remove();
						units.remove();
//						u.getPreds().clear();
//						u.getSuccs().clear();
					}
				}
				// 至此之前是对一个sootMethod的directedGraph中的每一个Unit处理
				for (Unit enter : dg.getHeads()) {
					List<Unit> Succs = new ArrayList<Unit>(dg.getSuccsOf(enter));
//					List<Unit> Succs = new ArrayList<Unit>(enter.getSuccs());
					if (Succs != null && Succs.size() != 0) {
						for (int i = 0; i < Succs.size(); i++) {
							if (!(Succs.get(i).getClass().toString().equals("class soot.jimple.internal.JInvokeStmt")
									|| (Succs.get(i).getClass().toString()
											.equals("class soot.jimple.internal.JAssignStmt")
											&& Succs.get(i).toString().matches(regEx))
									|| dg.getTails().contains(Succs.get(i)))
									|| (Succs.get(i).getClass().toString()
											.equals("class soot.jimple.internal.JInvokeStmt")
											&& Succs.get(i).toString().contains(": void <init>("))) {
//								enter.removeSuccs(Succs.get(i));
								dg.getSuccsOf(enter).remove(Succs.get(i));
							}
						}
					}
				}
				for (Unit tail : dg.getTails()) {
					// System.out.println("删除前出口的前驱："+tail.getPreds());
					List<Unit> Preds = new ArrayList<Unit>(dg.getPredsOf(tail));
					if (Preds != null && Preds.size() != 0) {
						for (int i = 0; i < Preds.size(); i++) {
							if (!(Preds.get(i).getClass().toString().equals("class soot.jimple.internal.JInvokeStmt")
									|| (Preds.get(i).getClass().toString()
											.equals("class soot.jimple.internal.JAssignStmt")
											&& Preds.get(i).toString().matches(regEx))
									|| dg.getHeads().contains(Preds.get(i)))
									|| (Preds.get(i).getClass().toString()
											.equals("class soot.jimple.internal.JInvokeStmt")
											&& Preds.get(i).toString().contains(": void <init>("))) {
//								tail.removePreds(Preds.get(i));
								dg.getPredsOf(tail).remove(Preds.get(i));
							}

						}
					}
					// System.out.println("出口的前驱："+tail.getPreds());
				}
				for (Iterator<Unit> units = dg.iterator(); units.hasNext();) {
					Unit u = units.next();
					if ((!dg.getPredsOf(u).isEmpty() || !dg.getSuccsOf(u).isEmpty()) && !dg.getHeads().contains(u)
//					if ((!u.getPreds().isEmpty() || !u.getSuccs().isEmpty()) && !dg.getHeads().contains(u)
							&& !dg.getTails().contains(u)) {
						// System.out.println("对于："+u);
						List<Unit> savePreds = new ArrayList<Unit>(dg.getPredsOf(u));
						List<Unit> saveSuccs = new ArrayList<Unit>(dg.getSuccsOf(u));
//						List<Unit> savePreds = new ArrayList<Unit>(u.getPreds());
//						List<Unit> saveSuccs = new ArrayList<Unit>(u.getSuccs());
						for (Unit u1 : savePreds) {
							if (!(u1.getClass().toString().equals("class soot.jimple.internal.JInvokeStmt"))
									&& !(u1.getClass().toString().equals("class soot.jimple.internal.JAssignStmt")
											&& u1.toString().matches(regEx))
									&& !dg.getHeads().contains(u1)//u1.toString().equals("enterOf" + sm.toString())
									&& !dg.getTails().contains(u1)){//u1.toString().equals("returnOf" + sm.toString())) {
								// System.out.println("要移除的前驱："+u1+"类为："+u1.getClass());
                               dg.getPredsOf(u).remove(u1);
                               dg.getSuccsOf(u1).clear();
                               dg.getPredsOf(u1).clear();
//								u.removePreds(u1);
//								u1.getSuccs().clear();
//								u1.getPreds().clear();
								continue;
							}
							if (u1.getClass().toString().equals("class soot.jimple.internal.JInvokeStmt")
									&& u1.toString().contains(": void <init>(")) {
								dg.getPredsOf(u).remove(u1);
								dg.getSuccsOf(u1).clear();
								dg.getPredsOf(u1).clear();
//								u.removePreds(u1);
//								u1.getSuccs().clear();
//								u1.getPreds().clear();
								continue;
							}
							// System.out.println("剩余的前驱："+u1+"类为："+u1.getClass());
						}
						if (!dg.getPredsOf(u).isEmpty()) {
//						if (!u.getPreds().isEmpty()) {
							methodSize++;
						}
						for (Unit u2 : saveSuccs) {
							if (!(u2.getClass().toString().equals("class soot.jimple.internal.JInvokeStmt")
									|| (u2.getClass().toString().equals("class soot.jimple.internal.JAssignStmt")
											&& u2.toString().matches(regEx))
									|| dg.getHeads().contains(u2)//u2.toString().equals("enterOf" + sm.toString())
									||dg.getTails().contains(u2)// u2.toString().equals("returnOf" + sm.toString())
									|| (u2.getClass().toString().equals("class soot.jimple.internal.JInvokeStmt")
											&& u2.toString().contains(": void <init>(")))) {

								// System.out.println("要移除的后继："+u2+"类为："+u2.getClass());
                                dg.getSuccsOf(u).remove(u2);
                                dg.getPredsOf(u2).clear();
                                dg.getSuccsOf(u2).clear();
//                                units.remove();
//								u.removeSuccs(u2);
//								u2.getPreds().clear();
//								u2.getSuccs().clear();
								continue;
							}
							// System.out.println("剩余的后继："+u2+"类为："+u2.getClass());

						}
						if (!dg.getSuccsOf(u).isEmpty()) {

//						if (!u.getSuccs().isEmpty()) {
							methodSize++;
						}
					}
				}
				if (methodSize > 0) {
					for (Iterator<Unit> units = dg.iterator(); units.hasNext();) {
						Unit u = units.next();
                        if((!dg.getPredsOf(u).isEmpty()&&!dg.getSuccsOf(u).isEmpty())||dg.getHeads().contains(u)||dg.getTails().contains(u)){
//						if ((!u.getPreds().isEmpty()&&!u.getSuccs().isEmpty()) || dg.getHeads().contains(u)|| dg.getTails().contains(u)) {
							 if (!unitChain.contains(u)) {
             					unitChain.add(u);
								unitToSuccs.put(u, new ArrayList<Unit>(dg.getSuccsOf(u)));
								unitToPreds.put(u, new ArrayList<Unit>(dg.getPredsOf(u)));
//								unitToSuccs.put(u, new ArrayList<Unit>(u.getSuccs()));
//								unitToPreds.put(u, new ArrayList<Unit>(u.getPreds()));
							}
                                  	   
					}
					}
			}

				newDG = new NewDirectedGraph(dg.getHeads(),dg.getTails(), unitToSuccs, unitToPreds,sm,unitChain);
				
				if(!unitChain.isEmpty())
				{
//					System.out.println("过滤后方法："+sm);
//					for(Unit unit:unitChain){
//						System.out.println("节点："+unit);
//					System.out.println("前驱："+dg.getPredsOf(unit));
//					}
					newDGList.add(new NewDirectedGraph(new ArrayList<Unit>(dg.getHeads()),new ArrayList<Unit>(dg.getTails()),new HashMap<Unit,ArrayList<Unit>>(unitToSuccs), new HashMap<Unit,ArrayList<Unit>>(unitToPreds),sm,new PatchingChain<Unit>(unitChain)));
                   sumEnd+=unitChain.size();

				}
			}
			unitToSuccs.clear();
			unitToPreds.clear();
			if (sm.toString().equals("<dummyMainClass: void dummyMainMethod()>")) {
				DirectedGraph<Unit> dg = iCfg.getOrCreateUnitGraph(sm);
				for (Iterator<Unit> units = dg.iterator(); units.hasNext();) {
					Unit u = units.next();
					u.setPredsOf(new ArrayList<Unit>(dg.getPredsOf(u)));
					u.setSuccsOf(new ArrayList<Unit>(dg.getSuccsOf(u)));
				}
				for (Iterator<Unit> units = dg.iterator(); units.hasNext();) {
					Unit u = units.next();
					selfToSuccess.put(u, dg.getSuccsOf(u));
				}
				paths=DummyMainFilter.dfs(dg.getHeads(),selfToSuccess,dg.getTails());
			    List<Unit> pathList=new LinkedList<Unit>();
				for(Queue<Unit> path:paths){
				  for(Unit p:path){
					  pathList.add(p);
				  }
				  for(int i=0;i<pathList.size();i++){
					
				  if(i<=(pathList.size()-2))
				  {
//					  System.out.println(dg.getSuccsOf(pathList.get(i)));
					  dg.getSuccsOf(pathList.get(i)).clear();
					  dg.getPredsOf(pathList.get(i+1)).clear();
					  dg.getSuccsOf(pathList.get(i)).add(pathList.get(i+1));
					  dg.getPredsOf(pathList.get(i+1)).add(pathList.get(i));
//					  pathList.get(i).getSuccs().clear();
//					  pathList.get(i+1).getPreds().clear();
//					  pathList.get(i).getSuccs().add(pathList.get(i+1));
//					  pathList.get(i+1).getPreds().add(pathList.get(i));
					  unitChain.add(pathList.get(i));
					  unitToSuccs.put(pathList.get(i), new ArrayList<Unit>(dg.getSuccsOf(pathList.get(i))));
					  unitToPreds.put(pathList.get(i), new ArrayList<Unit>(dg.getPredsOf(pathList.get(i))));				  
//					  unitToSuccs.put(pathList.get(i), new ArrayList<Unit>(pathList.get(i).getSuccs()));
//					  unitToPreds.put(pathList.get(i), new ArrayList<Unit>(pathList.get(i).getPreds()));				  
				  continue;
				  }
				  else if(i==(pathList.size()-1)){
					  dg.getSuccsOf(pathList.get(i)).clear();
//					  pathList.get(i).getSuccs().clear();
					  unitChain.add(pathList.get(i));
					  unitToSuccs.put(pathList.get(i), new ArrayList<Unit>(dg.getSuccsOf(pathList.get(i))));
					  unitToPreds.put(pathList.get(i), new ArrayList<Unit>(dg.getPredsOf(pathList.get(i))));	
//					  unitToSuccs.put(pathList.get(i), new ArrayList<Unit>(pathList.get(i).getSuccs()));
//					  unitToPreds.put(pathList.get(i), new ArrayList<Unit>(pathList.get(i).getPreds()));				  
				  continue;
				}
			 }
		  }
		if(!unitChain.isEmpty())
	  {
		newDGList.add(new NewDirectedGraph(new ArrayList<Unit>(dg.getHeads()),new ArrayList<Unit>(dg.getTails()),new HashMap<Unit,ArrayList<Unit>>(unitToSuccs), new HashMap<Unit,ArrayList<Unit>>(unitToPreds),sm,new PatchingChain<Unit>(unitChain)));
	  }		
			unitToSuccs.clear();
			unitToPreds.clear();
	   }
			
	}
}

	public static void main(final String[] args) {
		getGraph();
//		System.out.println("过滤前节点数："+sumBegin);
//		System.out.println("过滤后节点数："+sumEnd);
	}
}
