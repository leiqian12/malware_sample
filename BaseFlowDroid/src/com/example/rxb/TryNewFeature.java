package com.example.rxb;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;

import com.example.af.AF;
import com.example.af.AFVertex;
import com.example.af.Graph;
import com.example.arraylist.graph;

import soot.MethodOrMethodContext;
import soot.SootMethod;
import soot.Unit;
import soot.jimple.Stmt;
import soot.jimple.infoflow.Infoflow;
import soot.jimple.infoflow.solver.IInfoflowCFG;
import soot.jimple.toolkits.callgraph.Edge;

public class TryNewFeature {
	static List<Unit> visitedVertex=new ArrayList<Unit>();
	public static IInfoflowCFG iCfg;
	public static Infoflow info = new Infoflow();
	public static List<NewDirectedGraph> newDGList = new ArrayList<NewDirectedGraph>();
	public static LinkedList<Unit> paths;
	public static Map<SootMethod, LinkedList<Unit>> methodOfPath = new HashMap<SootMethod, LinkedList<Unit>>();
	public static Map<SootMethod, LinkedList<Unit>> tempMethodOfPath = new HashMap<SootMethod,LinkedList<Unit>>();
	public static Set<Unit> visited;
	public static Collection<SootMethod> allMethod;
	public static List<List<Unit>> insertedPathList = new ArrayList<List<Unit>>();
    public static Map<Unit,Loop> unitMappingLoop=new HashMap<Unit,Loop>();
    static Set<Integer> searched = new HashSet<>();
    public static int dummyMainIndex;
    public static List<SootMethod> recursion=new ArrayList<SootMethod>();
	public static Vertex[] vertexArrayCFG;
	 static List<AFVertex> labelVertex=new ArrayList<AFVertex>();
	 static String regEx = "^.*[a-zA-Z]*[\\(]{1}.*[\\)]$";
	 public static List<SootMethod> methodsWithPath=new ArrayList<SootMethod>();
	 public static Map<Boolean, List<Unit>> overed = new HashMap<Boolean, List<Unit>>();
		//只是用来暂时存放一条路径衍生出来的产生多条路径，和insertedPathList相互切换
		public static List<List<Unit>> step2InsertedPathList = new ArrayList<List<Unit>>();
		//得到的用于下一轮迭代的路径集合，由每一个路径节点遍历完成后step2InsertedPathList和insertedPathList更新（逐渐加入）
		public static List<List<Unit>> newIteratorList = new ArrayList<List<Unit>>();
		//存放迭代完成的最终路径，这些路径将不参与下一次迭代
		public static List<List<Unit>> overInsertedPathList = new ArrayList<List<Unit>>();
		//存放用于下一轮迭代的路径集合，在上一轮完成后由newIteratorList更新，newIteratorList清空，用于记录下一次产生的新路径
		public static List<List<Unit>> replaceInsertedPathList = new ArrayList<List<Unit>>();
		public static Map<SootMethod,List<SootMethod>> methodList=new HashMap<SootMethod,List<SootMethod>>();
	static List<LinkedList<SootMethod>> allCycle = new ArrayList<LinkedList<SootMethod>>();
	public static List<LinkedList<Unit>> recursionPathList = new ArrayList<LinkedList<Unit>>();
	public static List<LinkedList<Unit>> sumRecursionPathList = new ArrayList<LinkedList<Unit>>();
	public static List<Queue<Unit>> noRecursionPathList = new ArrayList<Queue<Unit>>();
	public static LinkedList<Unit> delRecursion;
	public static Set<UnitEdge> edges=new HashSet<UnitEdge>();
	 static UnitEdge[] edgeArray;
	 public static AFVertex[] vertexArrayAF;
	 static Set<String> sourcesAndSinks = new HashSet<String>();
	 static CaculateSourceAndSink css=new CaculateSourceAndSink();
	 static Set<String> APIs = new HashSet<String>();
	 static int LoopNumber=0;
	 public static void main(final String[] args) {
		//在CFG中找环并将换压缩，找路径
		findLoop();
//		System.out.println("环的个数："+LoopNumber);
//		System.out.println("fenix分薛女士1");
		//将Loop中的环替换成节点
		replaceLoop();
//		System.out.println("fenix分薛女士2");
		//对递归的处理
		iteratorCall();
		
		for(SootMethod sm:tempMethodOfPath.keySet()){
			methodOfPath.remove(sm);
			methodOfPath.put(sm, tempMethodOfPath.get(sm));
		}
		for(SootMethod sm:methodOfPath.keySet()){
		System.out.println("方法："+sm);
		System.out.println("路径："+methodOfPath.get(sm).size());
//		for(Queue<Unit> path:methodOfPath.get(sm)){
//			System.out.println("路径："+path);
//		}
	}
		getUnExtraInvoke();
         //首先，将dummyMain中的每个生命周期方法和回调方法替换成其方法体
//		step1();
		//迭代地对路径中包含路径的方法调用进行替换
		tryStep();
		for(Unit u:entryPaths.keySet()){
			System.out.println("驻点："+u);
			System.out.println("路径："+entryPaths.get(u));
		}
//		step2();
		
	}

	public static void getUnExtraInvoke(){
	try {
			css.calculateSourcesSinksEntrypoints("E:\\period\\我的研一\\伊阳贵毕业设计\\soot-infoflow-android-develop\\SourcesAndSinks.txt");
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		APIs=API.readAPI("E:\\period\\我的研一\\伊阳贵毕业设计\\soot-infoflow-android-develop\\API.txt");		
		}
	
	public static void findLoop(){
		getDirectedGraph.getGraph();
//		System.out.println("fenix分薛女士");
		iCfg = getDirectedGraph.iCfg;
		newDGList = getDirectedGraph.newDGList;
		allMethod = info.getMethodsForSeeds(iCfg);
		for (NewDirectedGraph signalGraph : newDGList) {	
			methodsWithPath.add(signalGraph.method);
//			System.out.println("方法："+signalGraph.method);
//			if(signalGraph.method.getDeclaringClass().hasSuperclass()){
//			System.out.println("声明类："+signalGraph.method.getDeclaringClass().getSuperclass());
//			}
			}
		for (NewDirectedGraph signalGraph : newDGList) {
		List<LinkedList<Unit>> Multipaths=new ArrayList<LinkedList<Unit>>();
			Collection<Loop> colls = LoopNestTree.computeLoops(signalGraph);
//			System.out.println("环的个数："+colls.size());
			LoopNumber+=colls.size();
			if (!colls.isEmpty()) {
				LoopNestTree lnt = new LoopNestTree(colls);
				for (Loop loop : lnt) {
					if (lnt.addNestLoop() != null) {
						if (lnt.addNestLoop().contains(loop)) {
							continue;
						}
					}
					Unit loopUnit = new dummyLoop("环节点" + loop.header);
					unitMappingLoop.put(loopUnit, loop);
					signalGraph.unitChain.add(loopUnit);
					signalGraph.unitToPreds.put(loopUnit, new ArrayList<Unit>());
					signalGraph.unitToSuccs.put(loopUnit, new ArrayList<Unit>());
					Collection<Stmt> exits = loop.getLoopExits();
					List<Unit> preds = signalGraph.getPredsOf(loop.header);
					for (Unit pred : preds) {
						if (!exits.contains((Stmt) pred) && !loop.loopStatements.contains((Stmt) pred)) {
							signalGraph.getSuccsOf(pred).remove(loop.header);
							if (!signalGraph.getSuccsOf(pred).contains(loopUnit)) {
								signalGraph.getSuccsOf(pred).add(loopUnit);
							}
							if (!signalGraph.getPredsOf(loopUnit).contains(pred)) {
								signalGraph.getPredsOf(loopUnit).add(pred);
							}
						}
					}
					for (Stmt exitStmt : exits) {
						List<Unit> succs = signalGraph.getSuccsOf(exitStmt);
						for (Unit succ : succs) {
							if (!succ.equals((Unit) loop.header) && !loop.loopStatements.contains((Stmt) succ)) {
								signalGraph.getPredsOf(succ).remove(exitStmt);
								if (!signalGraph.getPredsOf(succ).contains(loopUnit)) {
									signalGraph.getPredsOf(succ).add(loopUnit);
								}
								if (!signalGraph.getSuccsOf(loopUnit).contains(succ)) {
									signalGraph.getSuccsOf(loopUnit).add(succ);
								}
							}
						}
					}
				}
				for (Loop loop : colls) {
					for (Stmt loopNode : loop.loopStatements) {
						if (signalGraph.unitChain.contains((Unit) loopNode)) {
							signalGraph.unitChain.remove((Unit) loopNode);
						}
					}
				}
			}
			
			for (Unit head : signalGraph.heads) {
				if(!head.toString().contains("@caughtexception"))
				{
				paths=DFSOrder.dfs(signalGraph, head);
				String strFirst=null;
				String strEnd=null;
				int indexFirst=0;
				int indexEnd=0;
				boolean judge=false;
				if(paths.toString().contains("BRANCH")){
					judge=true;
				}
				LinkedList<Unit> replacePaths=new LinkedList<Unit>(paths);
				while(judge)
				{
					boolean can=false;
					paths=new LinkedList<Unit>(replacePaths);
				for(Unit one:paths){
					if(one.toString().contains("BRANCH_(")&&one.toString().contains("_OF")){
						strFirst=one.toString().substring(one.toString().indexOf("BRANCH_(")+8, one.toString().indexOf("_OF"));
						indexFirst=paths.indexOf(one);
						can=true;
					}
					if(one.toString().contains(")_BRANCH")&&one.toString().contains("_OF")&&can){
						strEnd=one.toString().substring(one.toString().indexOf(")_BRANCH")+8, one.toString().indexOf("_OF"));
					    indexEnd=paths.indexOf(one);
						break;
					}
					if(signalGraph.tails.contains(one)&&can)
					{
						strEnd=one.toString();
						indexEnd=paths.indexOf(one);
						break;
					}
				}
				if(indexFirst!=0&&indexEnd!=0){
					List<Unit> subList=paths.subList(indexFirst, indexEnd+1);					
					replacePaths.removeAll(subList);
					subList.set(0, new dummyLoop("("));
					if(subList.get(subList.size()-1).toString().contains(")_BRANCH"))
					{
					subList.set(subList.size()-1,new dummyLoop(")"));
					}
					else
					{
					subList.add(new dummyLoop(")"));	
					}
					int index1=-1;
					for(Unit pathNode:paths){
						if(pathNode.toString().equals(strFirst)){
							index1=paths.indexOf(pathNode);
						     break;
						}
					}
					if(index1!=-1){
					 replacePaths.addAll(index1+1, subList);
					}			
				}
				if(!replacePaths.toString().contains("BRANCH_(")){
					judge=false;
				}
			  }
			methodOfPath.put(signalGraph.method,new LinkedList<Unit>(replacePaths));
//			Multipaths.add(new LinkedList<Unit>(replacePaths));
			}
			}			
		}
	}
	public static Vertex findVertex(int index,Vertex[] labelArray){
		 return labelArray[index];
	 }
	public static void replaceLoop(){	
		for(SootMethod sm:methodOfPath.keySet()){
    		LinkedList<Unit> paths=methodOfPath.get(sm);
//     		for(LinkedList<Unit> path:paths){
//    			LinkedList<Unit> removeLoopPath = new LinkedList<Unit>();
//    			boolean judge=false;
    		  for(Unit node:paths){
				if(unitMappingLoop.containsKey(node)){
					paths.addAll(paths.indexOf(node),unitMappingLoop.get(node).loopStatements);
				}
			}
    	}
	}
	 public static Map<SootMethod,Collection<SootMethod>> tryCatch=new HashMap<SootMethod,Collection<SootMethod>>();
     public static void iteratorCall(){	
	    vertexArrayCFG = getDirectedGraph.vertexArray;
		CFGGraph graph = getDirectedGraph.graph;
		dummyMainIndex=getDirectedGraph.dummyMainIndex;
		int[][] e = graph.getAdjMat();
		int n = e.length;
		DsfCycle.deliver(e, n);
		DsfCycle.deleteDifferentSequenceSameCycle();
		for(List<Integer> list:DsfCycle.allCycle){
			List<SootMethod> oneCycle=new LinkedList<SootMethod>();
			for(int listIndex:list){
				oneCycle.add(findVertex(listIndex,vertexArrayCFG).getLabel().method());
			}
			allCycle.add(new LinkedList<SootMethod>(oneCycle));
		}
		System.out.println("环："+allCycle);
		if(!allCycle.isEmpty())
		{
		for(LinkedList<SootMethod> oneCycle:allCycle){
			for(int i=0;i<oneCycle.size();i++){
			LinkedList<Unit> paths=methodOfPath.get(oneCycle.get(i));
			
			int j=i;
		while(true)
		{
			j=j+1;
			if(j==oneCycle.size()){
			j=0;
			}
			List<Unit> insertedPath = new LinkedList<Unit>();
				for(Unit pathNode:paths){
					
				Collection<SootMethod> methods=iCfg.getCalleesOfCallAt(pathNode);			
				if(methods.contains(oneCycle.get(j))){
						LinkedList<Unit> callPaths=methodOfPath.get(oneCycle.get(j));						
							insertedPath.addAll(callPaths);
						
					}
					else{
							insertedPath.add(pathNode);
					}
				}
				paths=new LinkedList<Unit>(insertedPath);
				if(j+1==i||(i==0&&j==oneCycle.size()-1)){
				    delRecursion=new LinkedList<Unit>();
					for(Unit point:	paths){
						if(iCfg.getCalleesOfCallAt(point).contains(oneCycle.get(i))){
							Unit newCall=new dummyLoop("signed_"+point.toString());
							delRecursion.add(newCall);
						}
						else{
							delRecursion.add(point);
						}
					}
					break;
				   }
		     	 }	
		       tempMethodOfPath.put(oneCycle.get(i), delRecursion);
			   }		  		
			}
	      }
		}
     static Map<Unit,LinkedList<Unit>> entryPaths=new HashMap<Unit,LinkedList<Unit>>();
     public static void tryStep(){
		
		SootMethod dummyMain = null;
		for (SootMethod sm : methodOfPath.keySet()) {
			if (sm.toString().equals("<dummyMainClass: void dummyMainMethod()>")) {
				dummyMain = sm;
				break;
			}
		}
		 List<Unit> dummyPath=methodOfPath.get(dummyMain);
		 boolean judge=false;
		for (Unit pathNode : dummyPath){
			List<Unit> everyNodepath=new LinkedList<Unit>();
				SootMethod toFind = null;
				Collection<SootMethod> methodColls = iCfg.getCalleesOfCallAt(pathNode);
				for (SootMethod reserve : methodColls) {
					if (allMethod.contains(reserve)) {
						toFind = reserve;
						break;
					}
				}
				if (toFind != null && iCfg.isCallStmt(pathNode) && methodOfPath.keySet().contains(toFind)) {
				everyNodepath=methodOfPath.get(toFind);
				}
				if(!everyNodepath.isEmpty())
				{
			while(true){
				List<Unit> iterNew=new LinkedList<Unit>();
				for(Unit node:everyNodepath)
				{
				  SootMethod subMethod = null;
				Collection<SootMethod> subMethodColls = iCfg.getCalleesOfCallAt(node);
				for (SootMethod subReserve : subMethodColls) {
					if (allMethod.contains(subReserve)) {
						subMethod = subReserve;
						break;
					}
				}
				if (subMethod != null && iCfg.isCallStmt(node) && methodOfPath.keySet().contains(subMethod)) {
					iterNew.addAll(methodOfPath.get(toFind));
					judge=true;
				}
				else{
					iterNew.add(pathNode);
				}
				if(judge==false){
					entryPaths.put(pathNode,new LinkedList<Unit>(iterNew));
					break;
				}
				
				}
				everyNodepath=new LinkedList<Unit>(iterNew);
				}
			}
		}	
	}
}
